(self["webpackChunkmy_website"]=self["webpackChunkmy_website"]||[]).push([[501],{8501:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return f}});var l=t(8473),i=t(2333),o=i;const s="[A-Za-z$_][0-9A-Za-z$_]*",r=["as","in","of","if","for","while","finally","var","new","function","do","return","void","else","break","catch","instanceof","with","throw","case","default","try","switch","continue","typeof","delete","let","yield","const","class","debugger","async","await","static","import","from","export","extends"],a=["true","false","null","undefined","NaN","Infinity"],c=["Object","Function","Boolean","Symbol","Math","Date","Number","BigInt","String","RegExp","Array","Float32Array","Float64Array","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Int32Array","Uint16Array","Uint32Array","BigInt64Array","BigUint64Array","Set","Map","WeakSet","WeakMap","ArrayBuffer","SharedArrayBuffer","Atomics","DataView","JSON","Promise","Generator","GeneratorFunction","AsyncFunction","Reflect","Proxy","Intl","WebAssembly"],u=["Error","EvalError","InternalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError"],d=["setInterval","setTimeout","clearInterval","clearTimeout","require","exports","eval","isFinite","isNaN","parseFloat","parseInt","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape"],p=["arguments","this","super","console","window","document","localStorage","sessionStorage","module","global"],h=[].concat(d,c,u);function m(e){const n=e.regex,t=(e,n)=>{let{after:t}=n;const l="</"+e[0].slice(1),i=e.input.indexOf(l,t);return-1!==i},l=s,i={begin:"<>",end:"</>"},o=/<[A-Za-z0-9\\._:-]+\s*\/>/,m={begin:/<[A-Za-z0-9\\._:-]+/,end:/\/[A-Za-z0-9\\._:-]+>|\/>/,isTrulyOpeningTag:(e,n)=>{const l=e[0].length+e.index,i=e.input[l];if("<"===i||","===i)return void n.ignoreMatch();let o;">"===i&&(t(e,{after:l})||n.ignoreMatch());const s=e.input.substring(l);((o=s.match(/^\s*=/))||(o=s.match(/^\s+extends\s+/))&&0===o.index)&&n.ignoreMatch()}},g={$pattern:s,keyword:r,literal:a,built_in:h,"variable.language":p},b="[0-9](_?[0-9])*",f=`\\.(${b})`,k="0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*",y={className:"number",variants:[{begin:`(\\b(${k})((${f})|\\.)?|(${f}))[eE][+-]?(${b})\\b`},{begin:`\\b(${k})\\b((${f})\\b|\\.)?|(${f})\\b`},{begin:"\\b(0|[1-9](_?[0-9])*)n\\b"},{begin:"\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b"},{begin:"\\b0[bB][0-1](_?[0-1])*n?\\b"},{begin:"\\b0[oO][0-7](_?[0-7])*n?\\b"},{begin:"\\b0[0-7]+n?\\b"}],relevance:0},w={className:"subst",begin:"\\$\\{",end:"\\}",keywords:g,contains:[]},W={begin:"html`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,w],subLanguage:"xml"}},x={begin:"css`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,w],subLanguage:"css"}},E={begin:"gql`",end:"",starts:{end:"`",returnEnd:!1,contains:[e.BACKSLASH_ESCAPE,w],subLanguage:"graphql"}},_={className:"string",begin:"`",end:"`",contains:[e.BACKSLASH_ESCAPE,w]},U=e.COMMENT(/\/\*\*(?!\/)/,"\\*/",{relevance:0,contains:[{begin:"(?=@[A-Za-z]+)",relevance:0,contains:[{className:"doctag",begin:"@[A-Za-z]+"},{className:"type",begin:"\\{",end:"\\}",excludeEnd:!0,excludeBegin:!0,relevance:0},{className:"variable",begin:l+"(?=\\s*(-)|$)",endsParent:!0,relevance:0},{begin:/(?=[^\n])\s/,relevance:0}]}]}),N={className:"comment",variants:[U,e.C_BLOCK_COMMENT_MODE,e.C_LINE_COMMENT_MODE]},v=[e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,W,x,E,_,{match:/\$\d+/},y];w.contains=v.concat({begin:/\{/,end:/\}/,keywords:g,contains:["self"].concat(v)});const M=[].concat(N,w.contains),A=M.concat([{begin:/\(/,end:/\)/,keywords:g,contains:["self"].concat(M)}]),S={className:"params",begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:g,contains:A},O={variants:[{match:[/class/,/\s+/,l,/\s+/,/extends/,/\s+/,n.concat(l,"(",n.concat(/\./,l),")*")],scope:{1:"keyword",3:"title.class",5:"keyword",7:"title.class.inherited"}},{match:[/class/,/\s+/,l],scope:{1:"keyword",3:"title.class"}}]},R={relevance:0,match:n.either(/\bJSON/,/\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,/\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,/\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/),className:"title.class",keywords:{_:[...c,...u]}},j={label:"use_strict",className:"meta",relevance:10,begin:/^\s*['"]use (strict|asm)['"]/},I={variants:[{match:[/function/,/\s+/,l,/(?=\s*\()/]},{match:[/function/,/\s*(?=\()/]}],className:{1:"keyword",3:"title.function"},label:"func.def",contains:[S],illegal:/%/},P={relevance:0,match:/\b[A-Z][A-Z_0-9]+\b/,className:"variable.constant"};function C(e){return n.concat("(?!",e.join("|"),")")}const T={match:n.concat(/\b/,C([...d,"super","import"]),l,n.lookahead(/\(/)),className:"title.function",relevance:0},D={begin:n.concat(/\./,n.lookahead(n.concat(l,/(?![0-9A-Za-z$_(])/))),end:l,excludeBegin:!0,keywords:"prototype",className:"property",relevance:0},B={match:[/get|set/,/\s+/,l,/(?=\()/],className:{1:"keyword",3:"title.function"},contains:[{begin:/\(\)/},S]},L="(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|"+e.UNDERSCORE_IDENT_RE+")\\s*=>",H={match:[/const|var|let/,/\s+/,l,/\s*/,/=\s*/,/(async\s*)?/,n.lookahead(L)],keywords:"async",className:{1:"keyword",3:"title.function"},contains:[S]};return{name:"JavaScript",aliases:["js","jsx","mjs","cjs"],keywords:g,exports:{PARAMS_CONTAINS:A,CLASS_REFERENCE:R},illegal:/#(?![$_A-z])/,contains:[e.SHEBANG({label:"shebang",binary:"node",relevance:5}),j,e.APOS_STRING_MODE,e.QUOTE_STRING_MODE,W,x,E,_,N,{match:/\$\d+/},y,R,{className:"attr",begin:l+n.lookahead(":"),relevance:0},H,{begin:"("+e.RE_STARTERS_RE+"|\\b(case|return|throw)\\b)\\s*",keywords:"return throw case",relevance:0,contains:[N,e.REGEXP_MODE,{className:"function",begin:L,returnBegin:!0,end:"\\s*=>",contains:[{className:"params",variants:[{begin:e.UNDERSCORE_IDENT_RE,relevance:0},{className:null,begin:/\(\s*\)/,skip:!0},{begin:/\(/,end:/\)/,excludeBegin:!0,excludeEnd:!0,keywords:g,contains:A}]}]},{begin:/,/,relevance:0},{match:/\s+/,relevance:0},{variants:[{begin:i.begin,end:i.end},{match:o},{begin:m.begin,"on:begin":m.isTrulyOpeningTag,end:m.end}],subLanguage:"xml",contains:[{begin:m.begin,end:m.end,skip:!0,contains:["self"]}]}]},I,{beginKeywords:"while if switch catch for"},{begin:"\\b(?!function)"+e.UNDERSCORE_IDENT_RE+"\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",returnBegin:!0,label:"func.def",contains:[S,e.inherit(e.TITLE_MODE,{begin:l,className:"title.function"})]},{match:/\.\.\./,relevance:0},D,{match:"\\$"+l,relevance:0},{match:[/\bconstructor(?=\s*\()/],className:{1:"title.function"},contains:[S]},T,P,O,B,{match:/\$[(.]/}]}}var g=t(4731);const b={setup(){o.registerLanguage("javascript",m);(0,g.yj)();return(0,l.bv)((()=>{o.highlightAll()})),()=>(0,l.Wm)("div",null,[(0,l.Wm)("h1",null,[(0,l.Uk)("webpack的打包原理"),(0,l.Wm)("a",{class:"header-anchor",href:"#webpack的打包原理","aria-label":'Permalink to "webpack的打包原理 {#webpack的打包原理}"'},null)]),(0,l.Wm)("div",{className:"web-content"},[(0,l.Wm)("div",null,[(0,l.Wm)("h3",{id:"process"},[(0,l.Uk)("打包流程")]),(0,l.Wm)("p",null,[(0,l.Wm)("span",null,[(0,l.Uk)("打包开始前的准备工作")]),(0,l.Wm)("span",null,[(0,l.Uk)("打包过程中(编译阶段)")]),(0,l.Wm)("span",null,[(0,l.Uk)("打包结束后(成功和失败)")])]),(0,l.Wm)("br",null,null),(0,l.Uk)("这里考虑到"),(0,l.Wm)("code",null,[(0,l.Uk)("watch mode")]),(0,l.Uk)("(当文件变化时，将重新进行编译),要把编译阶段单独解耦。"),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("xxxxxxx1")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段")]),(0,l.Wm)("p",null,[(0,l.Uk)("webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段")]),(0,l.Wm)("img",{src:"",alt:"",className:"src"},null),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("xxxxxxx2")]),(0,l.Wm)("p",null,[(0,l.Uk)("webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段")]),(0,l.Wm)("p",null,[(0,l.Uk)("webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段")])]),(0,l.Wm)("br",null,null),(0,l.Wm)("div",null,[(0,l.Wm)("h3",{id:"stream"},[(0,l.Uk)("实现webpack事件流")]),(0,l.Wm)("p",null,[(0,l.Uk)("这里需要借助Tapable，它是一个类似与node.js中的EventEmitter的库，但"),(0,l.Wm)("strong",null,[(0,l.Uk)("专注于自定义事件的触发和处理")]),(0,l.Uk)("通过Tapable我们可以注册自定义事件，然后在适当的时机去执行自定义事件。")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("我们可以通过tapable先注册一系列的生命周期函数，然后在合适的时间点执行。")]),(0,l.Wm)("br",null,null),(0,l.Uk)("比如："),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",{class:"language-javascript"},[["const {'SyncHook'} = require('tapable'), //这是一个同步钩子","\n//第一步：实例化钩子函数，可以在这里定义形参","\nconst syncHook = new SyncHook(['author', 'age'])","\n//第二步：注册事件1","\nsyncHook.tap('监听器1', (name, age)=>{\n console.log('监听器1:', 'name', 'age')\n});","\n//第三步：注册事件2","\nsyncHook.tap('监听器2', (name) =>;{\n console.log('监听器2', name)\n});","\n//第四步：注册事件3","\nsyncHook.tap('监听器3', (name) =>;{\n console.log('监听器3', name)\n});","\n//第五步：触发事件，这里传的是实参，会被每一个注册函数接收到","\nsyncHook.call('麦林', '100')"]])])]),(0,l.Wm)("br",null,null),(0,l.Uk)("在webpack中，就是通过tapable在compiler和compilation上像这样挂载着一系列"),(0,l.Wm)("code",null,[(0,l.Uk)("生命周期Hook")]),(0,l.Uk)("，它就像是一座桥梁，宽川着整个构建过程:"),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compiler {","\n  constructor() {","\n    //它内部提供了很多钩子","\n    this.hooks = {","\n      run: new SyncHook(), //会在编译刚开始的时候触发此钩子","\n      done: new SyncHook(), //会在编译结束的时候触发此钩子","\n    };","\n  };","\n}"]])])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("div",null,[(0,l.Wm)("h3",{id:"realization"},[(0,l.Uk)("具体实现")]),(0,l.Wm)("ul",null,[(0,l.Wm)("li",null,[(0,l.Uk)("(1) 搭建结构，读取配置参数")]),(0,l.Wm)("li",null,[(0,l.Uk)("(2) 用配置参数对象初始化"),(0,l.Wm)("code",null,[(0,l.Uk)("Compiler")]),(0,l.Uk)("对象")]),(0,l.Wm)("li",null,[(0,l.Uk)("(3) 挂载配置文件中的插件")]),(0,l.Wm)("li",null,[(0,l.Uk)("(4) 执行"),(0,l.Wm)("code",null,[(0,l.Uk)("Compiler")]),(0,l.Uk)("对象的"),(0,l.Wm)("code",null,[(0,l.Uk)("run")]),(0,l.Uk)("方法开始执行编译")]),(0,l.Wm)("li",null,[(0,l.Uk)("(5) 根据配置文件中"),(0,l.Wm)("code",null,[(0,l.Uk)("entry")]),(0,l.Uk)("配置项找到所有入口")]),(0,l.Wm)("li",null,[(0,l.Uk)("(6) 从入口文件出发，调用配置的"),(0,l.Wm)("code",null,[(0,l.Uk)("loader")]),(0,l.Uk)("规则，对各模块进行编译")]),(0,l.Wm)("li",null,[(0,l.Uk)("(7) 找出此模块所以来的模块，再对依赖模块进行编译")]),(0,l.Wm)("li",null,[(0,l.Uk)("(8) 等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块"),(0,l.Wm)("code",null,[(0,l.Uk)("chunk")])]),(0,l.Wm)("li",null,[(0,l.Uk)("(9) 把各个代码块"),(0,l.Wm)("code",null,[(0,l.Uk)("chunk")]),(0,l.Uk)("转换成一个一个文件加入到输出列表")])]),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("(1)、搭建结构，读取配置参数")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("webpack的本质是一个函数，它接受一个配置信息作为参数，执行返回一个")," ",(0,l.Wm)("span",null,[(0,l.Wm)("code",null,[(0,l.Uk)("compiler对象")])]),(0,l.Uk)("，调用compiler对象中的run方法则启动编译。run 方法接受一个回调，可以用来查看编译过程中的错误信息或编译信息")]),(0,l.Wm)("br",null,null),(0,l.Wm)("div",null,[(0,l.Wm)("i",null,[(0,l.Uk)("搭建结构:")])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compiler{","\n constructor(){}","\n\n run(callback){}","\n}","\n\n","//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数","\nfunction webpack(webpackOptions) {","\n  const compiler = new Compiler()","\n  return compiler;","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("(2)、用配置参数对象初始化"),(0,l.Wm)("code",null,[(0,l.Uk)("Compiler")]),(0,l.Uk)("对象")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compiler{","\n constructor(wewbpackOptions){","\n   this.options = webpackOptions, //存储配置信息","\n   //它内部提供了很多钩子","\n    this.hooks = {","\n      run: new SyncHook(), //会在编译刚开始的时候触发此钩子","\n      done: new SyncHook(), //会在编译结束的时候触发此钩子","\n    };","}","\n}","\n\n","//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数","\nfunction webpack(webpackOptions) {","\n  const compiler = new Compiler()","\n  return compiler;","}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("(3)、挂载配置文件中的插件")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("webpack plugin 是一个带有apply方法的构造函数。apply方法接收")," ",(0,l.Wm)("span",null,[(0,l.Wm)("code",null,[(0,l.Uk)("compiler对象")])]),(0,l.Uk)("为参数，当webpack内部进行插件挂载时会执行apply函数。我们可以在 apply方法中订阅各种生命周期钩子，当到达对应的时间点时就会执行。")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["//自定义插件WebpackRunPlugin","\nclass WebpackRunPlugin{","\n apply(compiler){","\n   compiler.hooks.run.tap('WebpackRunPlugin',()=>{","\n     console.log('开始编译')","\n   });","\n}","\n\n","//自定义插件WebpackDonePlugin","\nclass WebpackRunPlugin{","\n apply(compiler){","\n   compiler.hooks.done.tap('WebpackDonePlugin',()=>{","\n     console.log('编译完成')","\n   });","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("webpack.config.js:")]),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["const {WebpackRunPlugin,WebpackDonePlugin} = require('./webpack');","\nmodule.exports = {","\n plugins:[new WebpackRunPlugin(),new WebpackDonePlugin()]","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("执行插件的apply方法")]),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数","\nfunction webpack(webpackOptions){","\n  //第二步：用配置参数对象初始化`compiler`对象","\n  const compiler = new Compiler(webpackOptions);","\n  // 第三步：挂载配置文件中的插件","\n  const {plugins} = webpackOptions;","\n  for(let plugin of plugins){","\n    plugin.apply(compiler);","\n  }","\n  return compiler;","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("(4) 执行Compiler对象的run方法开始执行编译")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("在正式开始编译前，我们需要先调用Compiler中的run钩子，表示开始启动编译；编译结束后，需要调用done钩子，表示编译完成")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compiler{","\n constructor(){","\n  //省略","\n}","\n compiler(){","\n  //","\n}","\n\n//第四步：执行`compiler` 对象的`run方法开始执行编译`","\n run(callback){","\n   this.hooks.run.call(); //在编译前触发触发run钩子","\n   const onCompiled = ()=>{","\n     this.hooks.run.call(); //在编译前触发触发run钩子","\n   };","\n   this.compiler(onCompiled); //开始编译，成功之后调用onCompiled","\n }","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("编译这个阶段需要单独解耦出来，通过"),(0,l.Wm)("span",null,[(0,l.Wm)("code",null,[(0,l.Uk)("Compilation")])]),(0,l.Uk)("来完成，定义"),(0,l.Wm)("span",null,[(0,l.Wm)("code",null,[(0,l.Uk)("Compilation")])]),(0,l.Uk)("大致结构：")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compiler{","\n  //省略其他","\n run(callback){","\n //省略","\n }","\n compile(callback){","\n   let compilation = new Compilation(this.options);","\n   compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调","\n }","\n}","\n\n","class Compilation{","\n constructor(webpackOptions){","\n   this.options = webpackOptions;","\n   this.modules = []; //本次编译所有生成出来的模块","\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块","\n   this.assets = []; //本次编译产出的资源文件","\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译","\n }","\n\n","\n build(callback){","\n  // 这里开始做编译工作，编译成功之后执行callback","\n  callback()","\n }","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("(5) 根据配置文件中的"),(0,l.Wm)("code",null,[(0,l.Uk)("entry")]),(0,l.Uk)("配置项找到所有的入口")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("现在我们开始进行编译")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("编译开始前，我需要先知道入口文件，而"),(0,l.Wm)("span",null,[(0,l.Wm)("code",null,[(0,l.Uk)("入口的配置方式")])]),(0,l.Uk)("有多种，可以是字符串，也可以是对象，这一步是统一配置信息的格式，找出 所有入口(考虑多入口打包的场景)")]),(0,l.Wm)("br",null,null),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compilation{","\n constructor(webpackOptions){","\n   this.options = webpackOptions;","\n   this.modules = []; //本次编译所有生成出来的模块","\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块","\n   this.assets = []; //本次编译产出的资源文件","\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译","\n }","\n\n","\n build(callback){","\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口","\n  let entry = {};","\n  if(typeof this.options.entry === 'string'){","\n    entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容","\n  }else {","\n   entry = this.options.entry;","\n  }","\n\n  //编译成功执行callback","\n  callback()","\n }","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("(6) 从入口文件出发，调用配置的"),(0,l.Wm)("code",null,[(0,l.Uk)("loader")]),(0,l.Uk)("规则，对各模块进行编译")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("loader 本质上就是函数，接收资源文件或者上一个loader产生的结果作为入参，最终输出转换后的结果")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("写两个自定义loader配置到webpack.config.js中：")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["const loader1 = () = > {","\n return source + '// 给你的代码加点注释：loader1';","\n};","\n\n","const loader2 = () = > {","\n return source + '// 给你的代码加点注释：loader2';","\n};","\n\n//webpack.config.js:","const {loader1,loader2} = require('./webpack');","\nmodule.exports = {","\n modules:{","\n  rules:[","\n   {","\n    test:/.js$/","\n    use:[loader1,loader2]","\n   }","\n  ]","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("这一步骤将从入口文件出发，然后查找出对应的 Loader 对源代码进行翻译和替换。主要有三点")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("label",null,[(0,l.Uk)("1.入口文件的绝对路径添加到依赖数组中；")]),(0,l.Wm)("label",null,[(0,l.Uk)("2.得到入口模块的"),(0,l.Wm)("span",null,[(0,l.Wm)("code",null,[(0,l.Uk)("module")])]),(0,l.Uk)("对象；(读取模块内容，创建模块对象，对源代码进行翻译转换)")]),(0,l.Wm)("label",null,[(0,l.Uk)("3.将生成的入口文件"),(0,l.Wm)("span",null,[(0,l.Wm)("code",null,[(0,l.Uk)("module")])]),(0,l.Uk)("对象push进行this.modules中；")])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["const baseDir = process.cwd().replace(//g,'/');","\n\n","class Compilation{","\n constructor(webpackOptions){","\n   this.options = webpackOptions;","\n   this.modules = []; //本次编译所有生成出来的模块","\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块","\n   this.assets = []; //本次编译产出的资源文件","\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译","\n }","\n\n","\n buildModule(){","\n   // 读取模块内容。获取源代码","\n   let sourceCode = fs.readFileSync(modulePath,'utf8');","\n   // buildModule最终会返回一个modules对象，每个模块都会有一个id，id是相对于根目录的相对路径","\n   let moduleId = './' + path.posix.relative(baseDir,modulePath); //模块id：从根目录出发，找到与该模块的相对路径(./src/index.js)","\n   // 创建模块对象","\n   let module = {","\n     id: moduleId,","\n     names: [name], //names设计成数组是因为代表的是此模块属于哪个代码块，可能属于多个代码块","\n     dependencies: [], //它依赖的模块","\n     _source: '', //该模块的代码信息","\n   };","\n   // 找到对应的`loader`对源代码进行翻译和转换","\n   let loaders = []","\n   let { rules = []} = this.options.module;","\n   rules.forEach(rule=>{","\n     let { test } = rule;","\n     // 如果模块的路径和正则匹配，就把此规则对应的loader添加到loader数组中","\n     if(modulePath.match(test)){","\n       loaders.push(...rule.use)","\n     }","\n   });","\n\n//自右向做左对模块进行转移","\n sourceCode = loaders.reduceRight((code , loader) =>{","\n   return loader(code);","\n}, sourceCode);","\n\n   return module;","\n }","\n\n build(callback){","\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口","\n  let entry = {};","\n  if(typeof this.options.entry === 'string'){","\n  entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容","\n  }else {","\n  entry = this.options.entry;","\n  }","\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译","\n  for(let entryName in entry){","\n  let entryFilePath = path.posix.join(baseDir,entry[entryName]); ","\n  //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 ","\n  this.fileDependencies.push(entryFilePath);","\n  //2. 得到入口模块的`module` 对象","\n  let entryModule = this.buildModule(entryName,entryFilePath) ","\n  //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 ","\n  this.modules.push(entryModule);","\n  }","\n\n  //编译成功执行callback","\n  callback()","\n }","\n}"]])])]),(0,l.Wm)("h4",null,[(0,l.Uk)("(7) 找出此模块所依赖的模块，再对依赖模块进行编译")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("该步骤经过细化可以将其拆分成十个小步骤："),(0,l.Wm)("span",null,[(0,l.Uk)("（7.1）：先把源代码编译成 AST")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.2）：在 AST 中查找 require 语句，找出依赖的模块名称和绝对路径")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.3）：将依赖模块的绝对路径 push 到 this.fileDependencies 中")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.4）：生成依赖模块的模块 id")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.5）：修改语法结构，把依赖的模块改为依赖模块 id")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.6）：将依赖模块的信息 push 到该模块的 dependencies 属性中")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.7）：生成新代码，并把转译后的源代码放到 module._source 属性上")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.8）：对依赖模块进行编译（对 module 对象中的 dependencies 进行递归执行 buildModule ）")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.9）：对依赖模块编译完成后得到依赖模块的 module 对象，push 到 this.modules 中")]),(0,l.Wm)("span",null,[(0,l.Uk)("（7.10）：等依赖模块全部编译完成后，返回入口模块的 module 对象")])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["const parser = require('@babel/parser');","\n let types = require('@babel/types'); //用来生成或者判断节点的AST语法树的节点","\n const traverse = require('@babel/traverse').default;","\n const generator = require('@babel/generator').default;","\n","\n//获取文件路径","\n function tryExtensions(modulePath, extensions) {","\n   if (fs.existsSync(modulePath)) {","\n     return modulePath;","\n   }","\n   for (let i = 0; i < extensions?.length; i++) {","\n     let filePath = modulePath + extensions[i];","\n     if (fs.existsSync(filePath)) {","\n       return filePath;","\n     }","\n   }","\n   throw new Error(`无法找到${modulePath}`);","\n }","\n\nconst baseDir = process.cwd().replace(//g,'/');","\n\n","class Compilation{","\n constructor(webpackOptions){","\n   this.options = webpackOptions;","\n   this.modules = []; //本次编译所有生成出来的模块","\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块","\n   this.assets = []; //本次编译产出的资源文件","\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译","\n }","\n\n","\n buildModule(){","\n  //省略其他","\n\n//自右向做左对模块进行转移","\n  sourceCode = loaders.reduceRight((code , loader) =>{","\n   return loader(code);","\n  }, sourceCode);","\n\n//通过loader翻译后的内容一定得是js内容，因为最后得走我们babel-parse，只有js才能成编译AST","\n  //第七步：找出此模块所依赖的模块，再对依赖模块进行编译","\n  //7.1:先把源代码编译成 [AST](https://astexplorer.net/)","\n   let ast = parser.parse(sourceCode, { sourceType: 'module' });","\n    traverse(ast, {","\n    CallExpression: (nodePath) => {","\n    const { node } = nodePath;","\n    //7.2在 `AST` 中查找 `require` 语句，找出依赖的模块名称和绝对路径","\n    if (node.callee.name === 'require') {","\n      let depModuleName = node.arguments[0].value; //获取依赖的模块","\n      let dirname = path.posix.dirname(modulePath); //获取当前正在编译的模所在的目录","\n      let depModulePath = path.posix.join(dirname, depModuleName); //获取依赖模块的绝对路径","\n      let extensions = this.options.resolve?.extensions || [ '.js' ]; //获取配置中的extensions","\n      depModulePath = tryExtensions(depModulePath, extensions); //尝试添加后缀，找到一个真实在硬盘上存在的文件","\n      //7.3:将依赖模块的绝对路径 push 到 `this.fileDependencies` 中","\n      this.fileDependencies.push(depModulePath);","\n      //7.4:生成依赖模块的`模块 id`","\n      let depModuleId = './' + path.posix.relative(baseDir, depModulePath);","\n      //7.5:修改语法结构，把依赖的模块改为依赖`模块 id` require('./name')=>require('./src/name.js')","\n      node.arguments = [types.stringLiteral(depModuleId)];","\n      //7.6:将依赖模块的信息 push 到该模块的 `dependencies` 属性中","\n      module.dependencies.push({ depModuleId, depModulePath });","\n    }","\n    });","\n\n//7.7：生成新代码，并把转译后的源代码放到 `module._source` 属性上","\n   let { code } = generator(ast);","\n   module._source = code;","\n   //7.8：对依赖模块进行编译（对 `module 对象`中的 `dependencies` 进行递归执行 `buildModule` ）","\n   module.dependencies.forEach(({ depModuleId, depModulePath }) => {","\n   //考虑到多入口打包 ：一个模块被多个其他模块引用，不需要重复打包","\n   let existModule = this.modules.find((item) => item.id === depModuleId);","\n   //如果modules里已经存在这个将要编译的依赖模块了，那么就不需要编译了，直接把此代码块的名称添加到对应模块的names字段里就可以","\n   if (existModule) {","\n     //names指的是它属于哪个代码块chunk","\n     existModule.names.push(name);","\n   } else {","\n     //7.9：对依赖模块编译完成后得到依赖模块的 `module 对象`，push 到 `this.modules` 中","\n     let depModule = this.buildModule(name, depModulePath);","\n     this.modules.push(depModule);","\n   }","\n   });","\n   //7.10：等依赖模块全部编译完成后，返回入口模块的 `module` 对象","\n   return module;","\n }","\n\n build(callback){","\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口","\n  let entry = {};","\n  if(typeof this.options.entry === 'string'){","\n  entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容","\n  }else {","\n  entry = this.options.entry;","\n  }","\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译","\n  for(let entryName in entry){","\n    let entryFilePath = path.posix.join(baseDir,entry[entryName]); ","\n    //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 ","\n    this.fileDependencies.push(entryFilePath);","\n    //2. 得到入口模块的`module` 对象","\n    let entryModule = this.buildModule(entryName,entryFilePath) ","\n    //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 ","\n    this.modules.push(entryModule);","\n  }","\n\n  //编译成功执行callback","\n  callback()","\n }","\n}"]])])]),(0,l.Wm)("h4",null,[(0,l.Uk)("(8) 等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块"),(0,l.Wm)("code",null,[(0,l.Uk)("chunk")])]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("一般来说，每个入口文件会对应一个代码块chunk，每个代码块chunk里面会放着本入口模块和它依赖的模块，这里暂时不考虑代码分割")]),(0,l.Wm)("br",null,null),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compilation{","\n constructor(webpackOptions){","\n   this.options = webpackOptions;","\n   this.modules = []; //本次编译所有生成出来的模块","\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块","\n   this.assets = []; //本次编译产出的资源文件","\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译","\n }","\n\n","\n build(callback){","\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口","\n  let entry = {};","\n  if(typeof this.options.entry === 'string'){","\n    entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容","\n  }else {","\n   entry = this.options.entry;","\n  }","\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译","\n  for(let entryName in entry){","\n    let entryFilePath = path.posix.join(baseDir,entry[entryName]); ","\n    //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 ","\n    this.fileDependencies.push(entryFilePath);","\n    //2. 得到入口模块的`module` 对象","\n    let entryModule = this.buildModule(entryName,entryFilePath) ","\n    //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 ","\n    this.modules.push(entryModule);","\n    //第八步：等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 `chunk`（一般来说，每个入口文件会对应一个代码块`chunk`，每个代码块`chunk`里面会放着本入口","模块  和它依赖的模块","\n    let chunk = {","\n     name: entryName, //entryName='main' 代码块的名称","\n     entryModule, //此代码块对应的module的对象,这里就是src/index.js 的module对象","\n     modules: this.modules.filter((item) => item.names.includes(entryName)), //找出属于该代码块的模块","\n    }","\n    this.chunks.push(chunk);","\n  }","\n\n  //编译成功执行callback","\n  callback()","\n }","\n}"]])])]),(0,l.Wm)("br",null,null),(0,l.Wm)("h4",null,[(0,l.Uk)("(9) 把各个代码块"),(0,l.Wm)("code",null,[(0,l.Uk)("chunk")]),(0,l.Uk)("转换成一个一个文件加入到输出列表")]),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Uk)("这一步需要结合配置文件中的output.filename去生成输出文件的文件名称，同时还需要生成运行时代码:")]),(0,l.Wm)("br",null,null),(0,l.Wm)("br",null,null),(0,l.Wm)("p",null,[(0,l.Wm)("pre",null,[(0,l.Wm)("code",null,[["class Compilation{","\n constructor(webpackOptions){","\n   this.options = webpackOptions;","\n   this.modules = []; //本次编译所有生成出来的模块","\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块","\n   this.assets = []; //本次编译产出的资源文件","\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译","\n }","\n\n","\n build(callback){","\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口","\n  let entry = {};","\n  if(typeof this.options.entry === 'string'){","\n    entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容","\n  }else {","\n   entry = this.options.entry;","\n  }","\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译","\n  for(let entryName in entry){","\n    let entryFilePath = path.posix.join(baseDir,entry[entryName]); ","\n    //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 ","\n    this.fileDependencies.push(entryFilePath);","\n    //2. 得到入口模块的`module` 对象","\n    let entryModule = this.buildModule(entryName,entryFilePath) ","\n    //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 ","\n    this.modules.push(entryModule);","\n    //第八步：等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 `chunk`（一般来说，每个入口文件会对应一个代码块`chunk`，每个代码块`chunk`里面会放着本入口","模块  和它依赖的模块","\n    let chunk = {","\n     name: entryName, //entryName='main' 代码块的名称","\n     entryModule, //此代码块对应的module的对象,这里就是src/index.js 的module对象","\n     modules: this.modules.filter((item) => item.names.includes(entryName)), //找出属于该代码块的模块","\n    }","\n    this.chunks.push(chunk);","\n  }","\n\n  //编译成功执行callback","\n  callback()","\n }","\n}"]])])])])])])}};var f=b},2333:function(e){function n(e){return e instanceof Map?e.clear=e.delete=e.set=function(){throw new Error("map is read-only")}:e instanceof Set&&(e.add=e.clear=e.delete=function(){throw new Error("set is read-only")}),Object.freeze(e),Object.getOwnPropertyNames(e).forEach((t=>{const l=e[t],i=typeof l;"object"!==i&&"function"!==i||Object.isFrozen(l)||n(l)})),e}class t{constructor(e){void 0===e.data&&(e.data={}),this.data=e.data,this.isMatchIgnored=!1}ignoreMatch(){this.isMatchIgnored=!0}}function l(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")}function i(e){const n=Object.create(null);for(const o in e)n[o]=e[o];for(var t=arguments.length,l=new Array(t>1?t-1:0),i=1;i<t;i++)l[i-1]=arguments[i];return l.forEach((function(e){for(const t in e)n[t]=e[t]})),n}const o="</span>",s=e=>!!e.scope,r=(e,n)=>{let{prefix:t}=n;if(e.startsWith("language:"))return e.replace("language:","language-");if(e.includes(".")){const n=e.split(".");return[`${t}${n.shift()}`,...n.map(((e,n)=>`${e}${"_".repeat(n+1)}`))].join(" ")}return`${t}${e}`};class a{constructor(e,n){this.buffer="",this.classPrefix=n.classPrefix,e.walk(this)}addText(e){this.buffer+=l(e)}openNode(e){if(!s(e))return;const n=r(e.scope,{prefix:this.classPrefix});this.span(n)}closeNode(e){s(e)&&(this.buffer+=o)}value(){return this.buffer}span(e){this.buffer+=`<span class="${e}">`}}const c=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n={children:[]};return Object.assign(n,e),n};class u{constructor(){this.rootNode=c(),this.stack=[this.rootNode]}get top(){return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(e){this.top.children.push(e)}openNode(e){const n=c({scope:e});this.add(n),this.stack.push(n)}closeNode(){if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){while(this.closeNode());}toJSON(){return JSON.stringify(this.rootNode,null,4)}walk(e){return this.constructor._walk(e,this.rootNode)}static _walk(e,n){return"string"===typeof n?e.addText(n):n.children&&(e.openNode(n),n.children.forEach((n=>this._walk(e,n))),e.closeNode(n)),e}static _collapse(e){"string"!==typeof e&&e.children&&(e.children.every((e=>"string"===typeof e))?e.children=[e.children.join("")]:e.children.forEach((e=>{u._collapse(e)})))}}class d extends u{constructor(e){super(),this.options=e}addText(e){""!==e&&this.add(e)}startScope(e){this.openNode(e)}endScope(){this.closeNode()}__addSublanguage(e,n){const t=e.root;n&&(t.scope=`language:${n}`),this.add(t)}toHTML(){const e=new a(this,this.options);return e.value()}finalize(){return this.closeAllNodes(),!0}}function p(e){return e?"string"===typeof e?e:e.source:null}function h(e){return b("(?=",e,")")}function m(e){return b("(?:",e,")*")}function g(e){return b("(?:",e,")?")}function b(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];const l=n.map((e=>p(e))).join("");return l}function f(e){const n=e[e.length-1];return"object"===typeof n&&n.constructor===Object?(e.splice(e.length-1,1),n):{}}function k(){for(var e=arguments.length,n=new Array(e),t=0;t<e;t++)n[t]=arguments[t];const l=f(n),i="("+(l.capture?"":"?:")+n.map((e=>p(e))).join("|")+")";return i}function y(e){return new RegExp(e.toString()+"|").exec("").length-1}function w(e,n){const t=e&&e.exec(n);return t&&0===t.index}const W=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;function x(e,n){let{joinWith:t}=n,l=0;return e.map((e=>{l+=1;const n=l;let t=p(e),i="";while(t.length>0){const e=W.exec(t);if(!e){i+=t;break}i+=t.substring(0,e.index),t=t.substring(e.index+e[0].length),"\\"===e[0][0]&&e[1]?i+="\\"+String(Number(e[1])+n):(i+=e[0],"("===e[0]&&l++)}return i})).map((e=>`(${e})`)).join(t)}const E=/\b\B/,_="[a-zA-Z]\\w*",U="[a-zA-Z_]\\w*",N="\\b\\d+(\\.\\d+)?",v="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",M="\\b(0b[01]+)",A="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",S=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const n=/^#![ ]*\//;return e.binary&&(e.begin=b(n,/.*\b/,e.binary,/\b.*/)),i({scope:"meta",begin:n,end:/$/,relevance:0,"on:begin":(e,n)=>{0!==e.index&&n.ignoreMatch()}},e)},O={begin:"\\\\[\\s\\S]",relevance:0},R={scope:"string",begin:"'",end:"'",illegal:"\\n",contains:[O]},j={scope:"string",begin:'"',end:'"',illegal:"\\n",contains:[O]},I={begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/},P=function(e,n){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const l=i({scope:"comment",begin:e,end:n,contains:[]},t);l.contains.push({scope:"doctag",begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0});const o=k("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/);return l.contains.push({begin:b(/[ ]+/,"(",o,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),l},C=P("//","$"),T=P("/\\*","\\*/"),D=P("#","$"),B={scope:"number",begin:N,relevance:0},L={scope:"number",begin:v,relevance:0},H={scope:"number",begin:M,relevance:0},$={begin:/(?=\/[^/\n]*\/)/,contains:[{scope:"regexp",begin:/\//,end:/\/[gimuy]*/,illegal:/\n/,contains:[O,{begin:/\[/,end:/\]/,relevance:0,contains:[O]}]}]},z={scope:"title",begin:_,relevance:0},F={scope:"title",begin:U,relevance:0},Z={begin:"\\.\\s*"+U,relevance:0},q=function(e){return Object.assign(e,{"on:begin":(e,n)=>{n.data._beginMatch=e[1]},"on:end":(e,n)=>{n.data._beginMatch!==e[1]&&n.ignoreMatch()}})};var G=Object.freeze({__proto__:null,MATCH_NOTHING_RE:E,IDENT_RE:_,UNDERSCORE_IDENT_RE:U,NUMBER_RE:N,C_NUMBER_RE:v,BINARY_NUMBER_RE:M,RE_STARTERS_RE:A,SHEBANG:S,BACKSLASH_ESCAPE:O,APOS_STRING_MODE:R,QUOTE_STRING_MODE:j,PHRASAL_WORDS_MODE:I,COMMENT:P,C_LINE_COMMENT_MODE:C,C_BLOCK_COMMENT_MODE:T,HASH_COMMENT_MODE:D,NUMBER_MODE:B,C_NUMBER_MODE:L,BINARY_NUMBER_MODE:H,REGEXP_MODE:$,TITLE_MODE:z,UNDERSCORE_TITLE_MODE:F,METHOD_GUARD:Z,END_SAME_AS_BEGIN:q});function K(e,n){const t=e.input[e.index-1];"."===t&&n.ignoreMatch()}function X(e,n){void 0!==e.className&&(e.scope=e.className,delete e.className)}function J(e,n){n&&e.beginKeywords&&(e.begin="\\b("+e.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",e.__beforeBegin=K,e.keywords=e.keywords||e.beginKeywords,delete e.beginKeywords,void 0===e.relevance&&(e.relevance=0))}function V(e,n){Array.isArray(e.illegal)&&(e.illegal=k(...e.illegal))}function Q(e,n){if(e.match){if(e.begin||e.end)throw new Error("begin & end are not supported with match");e.begin=e.match,delete e.match}}function Y(e,n){void 0===e.relevance&&(e.relevance=1)}const ee=(e,n)=>{if(!e.beforeMatch)return;if(e.starts)throw new Error("beforeMatch cannot be used with starts");const t=Object.assign({},e);Object.keys(e).forEach((n=>{delete e[n]})),e.keywords=t.keywords,e.begin=b(t.beforeMatch,h(t.begin)),e.starts={relevance:0,contains:[Object.assign(t,{endsParent:!0})]},e.relevance=0,delete t.beforeMatch},ne=["of","and","for","in","not","or","if","then","parent","list","value"],te="keyword";function le(e,n){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:te;const l=Object.create(null);return"string"===typeof e?i(t,e.split(" ")):Array.isArray(e)?i(t,e):Object.keys(e).forEach((function(t){Object.assign(l,le(e[t],n,t))})),l;function i(e,t){n&&(t=t.map((e=>e.toLowerCase()))),t.forEach((function(n){const t=n.split("|");l[t[0]]=[e,ie(t[0],t[1])]}))}}function ie(e,n){return n?Number(n):oe(e)?0:1}function oe(e){return ne.includes(e.toLowerCase())}const se={},re=e=>{console.error(e)},ae=function(e){for(var n=arguments.length,t=new Array(n>1?n-1:0),l=1;l<n;l++)t[l-1]=arguments[l];console.log(`WARN: ${e}`,...t)},ce=(e,n)=>{se[`${e}/${n}`]||(console.log(`Deprecated as of ${e}. ${n}`),se[`${e}/${n}`]=!0)},ue=new Error;function de(e,n,t){let{key:l}=t,i=0;const o=e[l],s={},r={};for(let a=1;a<=n.length;a++)r[a+i]=o[a],s[a+i]=!0,i+=y(n[a-1]);e[l]=r,e[l]._emit=s,e[l]._multi=!0}function pe(e){if(Array.isArray(e.begin)){if(e.skip||e.excludeBegin||e.returnBegin)throw re("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),ue;if("object"!==typeof e.beginScope||null===e.beginScope)throw re("beginScope must be object"),ue;de(e,e.begin,{key:"beginScope"}),e.begin=x(e.begin,{joinWith:""})}}function he(e){if(Array.isArray(e.end)){if(e.skip||e.excludeEnd||e.returnEnd)throw re("skip, excludeEnd, returnEnd not compatible with endScope: {}"),ue;if("object"!==typeof e.endScope||null===e.endScope)throw re("endScope must be object"),ue;de(e,e.end,{key:"endScope"}),e.end=x(e.end,{joinWith:""})}}function me(e){e.scope&&"object"===typeof e.scope&&null!==e.scope&&(e.beginScope=e.scope,delete e.scope)}function ge(e){me(e),"string"===typeof e.beginScope&&(e.beginScope={_wrap:e.beginScope}),"string"===typeof e.endScope&&(e.endScope={_wrap:e.endScope}),pe(e),he(e)}function be(e){function n(n,t){return new RegExp(p(n),"m"+(e.case_insensitive?"i":"")+(e.unicodeRegex?"u":"")+(t?"g":""))}class t{constructor(){this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}addRule(e,n){n.position=this.position++,this.matchIndexes[this.matchAt]=n,this.regexes.push([n,e]),this.matchAt+=y(e)+1}compile(){0===this.regexes.length&&(this.exec=()=>null);const e=this.regexes.map((e=>e[1]));this.matcherRe=n(x(e,{joinWith:"|"}),!0),this.lastIndex=0}exec(e){this.matcherRe.lastIndex=this.lastIndex;const n=this.matcherRe.exec(e);if(!n)return null;const t=n.findIndex(((e,n)=>n>0&&void 0!==e)),l=this.matchIndexes[t];return n.splice(0,t),Object.assign(n,l)}}class l{constructor(){this.rules=[],this.multiRegexes=[],this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(e){if(this.multiRegexes[e])return this.multiRegexes[e];const n=new t;return this.rules.slice(e).forEach((e=>{let[t,l]=e;return n.addRule(t,l)})),n.compile(),this.multiRegexes[e]=n,n}resumingScanAtSamePosition(){return 0!==this.regexIndex}considerAll(){this.regexIndex=0}addRule(e,n){this.rules.push([e,n]),"begin"===n.type&&this.count++}exec(e){const n=this.getMatcher(this.regexIndex);n.lastIndex=this.lastIndex;let t=n.exec(e);if(this.resumingScanAtSamePosition())if(t&&t.index===this.lastIndex);else{const n=this.getMatcher(0);n.lastIndex=this.lastIndex+1,t=n.exec(e)}return t&&(this.regexIndex+=t.position+1,this.regexIndex===this.count&&this.considerAll()),t}}function o(e){const n=new l;return e.contains.forEach((e=>n.addRule(e.begin,{rule:e,type:"begin"}))),e.terminatorEnd&&n.addRule(e.terminatorEnd,{type:"end"}),e.illegal&&n.addRule(e.illegal,{type:"illegal"}),n}function s(t,l){const i=t;if(t.isCompiled)return i;[X,Q,ge,ee].forEach((e=>e(t,l))),e.compilerExtensions.forEach((e=>e(t,l))),t.__beforeBegin=null,[J,V,Y].forEach((e=>e(t,l))),t.isCompiled=!0;let r=null;return"object"===typeof t.keywords&&t.keywords.$pattern&&(t.keywords=Object.assign({},t.keywords),r=t.keywords.$pattern,delete t.keywords.$pattern),r=r||/\w+/,t.keywords&&(t.keywords=le(t.keywords,e.case_insensitive)),i.keywordPatternRe=n(r,!0),l&&(t.begin||(t.begin=/\B|\b/),i.beginRe=n(i.begin),t.end||t.endsWithParent||(t.end=/\B|\b/),t.end&&(i.endRe=n(i.end)),i.terminatorEnd=p(i.end)||"",t.endsWithParent&&l.terminatorEnd&&(i.terminatorEnd+=(t.end?"|":"")+l.terminatorEnd)),t.illegal&&(i.illegalRe=n(t.illegal)),t.contains||(t.contains=[]),t.contains=[].concat(...t.contains.map((function(e){return ke("self"===e?t:e)}))),t.contains.forEach((function(e){s(e,i)})),t.starts&&s(t.starts,l),i.matcher=o(i),i}if(e.compilerExtensions||(e.compilerExtensions=[]),e.contains&&e.contains.includes("self"))throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");return e.classNameAliases=i(e.classNameAliases||{}),s(e)}function fe(e){return!!e&&(e.endsWithParent||fe(e.starts))}function ke(e){return e.variants&&!e.cachedVariants&&(e.cachedVariants=e.variants.map((function(n){return i(e,{variants:null},n)}))),e.cachedVariants?e.cachedVariants:fe(e)?i(e,{starts:e.starts?i(e.starts):null}):Object.isFrozen(e)?i(e):e}var ye="11.8.0";class we extends Error{constructor(e,n){super(e),this.name="HTMLInjectionError",this.html=n}}const We=l,xe=i,Ee=Symbol("nomatch"),_e=7,Ue=function(e){const l=Object.create(null),i=Object.create(null),o=[];let s=!0;const r="Could not find the language '{}', did you forget to load/include a language module?",a={disableAutodetect:!0,name:"Plain text",contains:[]};let c={ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",cssSelector:"pre code",languages:null,__emitter:d};function u(e){return c.noHighlightRe.test(e)}function p(e){let n=e.className+" ";n+=e.parentNode?e.parentNode.className:"";const t=c.languageDetectRe.exec(n);if(t){const n=I(t[1]);return n||(ae(r.replace("{}",t[1])),ae("Falling back to no-highlight mode for this block.",e)),n?t[1]:"no-highlight"}return n.split(/\s+/).find((e=>u(e)||I(e)))}function f(e,n,t){let l="",i="";"object"===typeof n?(l=e,t=n.ignoreIllegals,i=n.language):(ce("10.7.0","highlight(lang, code, ...args) has been deprecated."),ce("10.7.0","Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"),i=e,l=n),void 0===t&&(t=!0);const o={code:l,language:i};L("before:highlight",o);const s=o.result?o.result:y(o.language,o.code,t);return s.code=o.code,L("after:highlight",s),s}function y(e,n,i,o){const a=Object.create(null);function u(e,n){return e.keywords[n]}function d(){if(!S.keywords)return void R.addText(j);let e=0;S.keywordPatternRe.lastIndex=0;let n=S.keywordPatternRe.exec(j),t="";while(n){t+=j.substring(e,n.index);const l=v.case_insensitive?n[0].toLowerCase():n[0],i=u(S,l);if(i){const[e,o]=i;if(R.addText(t),t="",a[l]=(a[l]||0)+1,a[l]<=_e&&(P+=o),e.startsWith("_"))t+=n[0];else{const t=v.classNameAliases[e]||e;m(n[0],t)}}else t+=n[0];e=S.keywordPatternRe.lastIndex,n=S.keywordPatternRe.exec(j)}t+=j.substring(e),R.addText(t)}function p(){if(""===j)return;let e=null;if("string"===typeof S.subLanguage){if(!l[S.subLanguage])return void R.addText(j);e=y(S.subLanguage,j,!0,O[S.subLanguage]),O[S.subLanguage]=e._top}else e=x(j,S.subLanguage.length?S.subLanguage:null);S.relevance>0&&(P+=e.relevance),R.__addSublanguage(e._emitter,e.language)}function h(){null!=S.subLanguage?p():d(),j=""}function m(e,n){""!==e&&(R.startScope(n),R.addText(e),R.endScope())}function g(e,n){let t=1;const l=n.length-1;while(t<=l){if(!e._emit[t]){t++;continue}const l=v.classNameAliases[e[t]]||e[t],i=n[t];l?m(i,l):(j=i,d(),j=""),t++}}function b(e,n){return e.scope&&"string"===typeof e.scope&&R.openNode(v.classNameAliases[e.scope]||e.scope),e.beginScope&&(e.beginScope._wrap?(m(j,v.classNameAliases[e.beginScope._wrap]||e.beginScope._wrap),j=""):e.beginScope._multi&&(g(e.beginScope,n),j="")),S=Object.create(e,{parent:{value:S}}),S}function f(e,n,l){let i=w(e.endRe,l);if(i){if(e["on:end"]){const l=new t(e);e["on:end"](n,l),l.isMatchIgnored&&(i=!1)}if(i){while(e.endsParent&&e.parent)e=e.parent;return e}}if(e.endsWithParent)return f(e.parent,n,l)}function k(e){return 0===S.matcher.regexIndex?(j+=e[0],1):(D=!0,0)}function W(e){const n=e[0],l=e.rule,i=new t(l),o=[l.__beforeBegin,l["on:begin"]];for(const t of o)if(t&&(t(e,i),i.isMatchIgnored))return k(n);return l.skip?j+=n:(l.excludeBegin&&(j+=n),h(),l.returnBegin||l.excludeBegin||(j=n)),b(l,e),l.returnBegin?0:n.length}function E(e){const t=e[0],l=n.substring(e.index),i=f(S,e,l);if(!i)return Ee;const o=S;S.endScope&&S.endScope._wrap?(h(),m(t,S.endScope._wrap)):S.endScope&&S.endScope._multi?(h(),g(S.endScope,e)):o.skip?j+=t:(o.returnEnd||o.excludeEnd||(j+=t),h(),o.excludeEnd&&(j=t));do{S.scope&&R.closeNode(),S.skip||S.subLanguage||(P+=S.relevance),S=S.parent}while(S!==i.parent);return i.starts&&b(i.starts,e),o.returnEnd?0:t.length}function _(){const e=[];for(let n=S;n!==v;n=n.parent)n.scope&&e.unshift(n.scope);e.forEach((e=>R.openNode(e)))}let U={};function N(t,l){const o=l&&l[0];if(j+=t,null==o)return h(),0;if("begin"===U.type&&"end"===l.type&&U.index===l.index&&""===o){if(j+=n.slice(l.index,l.index+1),!s){const n=new Error(`0 width match regex (${e})`);throw n.languageName=e,n.badRule=U.rule,n}return 1}if(U=l,"begin"===l.type)return W(l);if("illegal"===l.type&&!i){const e=new Error('Illegal lexeme "'+o+'" for mode "'+(S.scope||"<unnamed>")+'"');throw e.mode=S,e}if("end"===l.type){const e=E(l);if(e!==Ee)return e}if("illegal"===l.type&&""===o)return 1;if(T>1e5&&T>3*l.index){const e=new Error("potential infinite loop, way more iterations than matches");throw e}return j+=o,o.length}const v=I(e);if(!v)throw re(r.replace("{}",e)),new Error('Unknown language: "'+e+'"');const M=be(v);let A="",S=o||M;const O={},R=new c.__emitter(c);_();let j="",P=0,C=0,T=0,D=!1;try{if(v.__emitTokens)v.__emitTokens(n,R);else{for(S.matcher.considerAll();;){T++,D?D=!1:S.matcher.considerAll(),S.matcher.lastIndex=C;const e=S.matcher.exec(n);if(!e)break;const t=n.substring(C,e.index),l=N(t,e);C=e.index+l}N(n.substring(C))}return R.finalize(),A=R.toHTML(),{language:e,value:A,relevance:P,illegal:!1,_emitter:R,_top:S}}catch(B){if(B.message&&B.message.includes("Illegal"))return{language:e,value:We(n),illegal:!0,relevance:0,_illegalBy:{message:B.message,index:C,context:n.slice(C-100,C+100),mode:B.mode,resultSoFar:A},_emitter:R};if(s)return{language:e,value:We(n),illegal:!1,relevance:0,errorRaised:B,_emitter:R,_top:S};throw B}}function W(e){const n={value:We(e),illegal:!1,relevance:0,_top:a,_emitter:new c.__emitter(c)};return n._emitter.addText(e),n}function x(e,n){n=n||c.languages||Object.keys(l);const t=W(e),i=n.filter(I).filter(C).map((n=>y(n,e,!1)));i.unshift(t);const o=i.sort(((e,n)=>{if(e.relevance!==n.relevance)return n.relevance-e.relevance;if(e.language&&n.language){if(I(e.language).supersetOf===n.language)return 1;if(I(n.language).supersetOf===e.language)return-1}return 0})),[s,r]=o,a=s;return a.secondBest=r,a}function E(e,n,t){const l=n&&i[n]||t;e.classList.add("hljs"),e.classList.add(`language-${l}`)}function _(e){let n=null;const t=p(e);if(u(t))return;if(L("before:highlightElement",{el:e,language:t}),e.children.length>0&&(c.ignoreUnescapedHTML||(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),console.warn("The element with unescaped HTML:"),console.warn(e)),c.throwUnescapedHTML)){const n=new we("One of your code blocks includes unescaped HTML.",e.innerHTML);throw n}n=e;const l=n.textContent,i=t?f(l,{language:t,ignoreIllegals:!0}):x(l);e.innerHTML=i.value,E(e,t,i.language),e.result={language:i.language,re:i.relevance,relevance:i.relevance},i.secondBest&&(e.secondBest={language:i.secondBest.language,relevance:i.secondBest.relevance}),L("after:highlightElement",{el:e,result:i,text:l})}function U(e){c=xe(c,e)}const N=()=>{A(),ce("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")};function v(){A(),ce("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")}let M=!1;function A(){if("loading"===document.readyState)return void(M=!0);const e=document.querySelectorAll(c.cssSelector);e.forEach(_)}function S(){M&&A()}function O(n,t){let i=null;try{i=t(e)}catch(o){if(re("Language definition for '{}' could not be registered.".replace("{}",n)),!s)throw o;re(o),i=a}i.name||(i.name=n),l[n]=i,i.rawDefinition=t.bind(null,e),i.aliases&&P(i.aliases,{languageName:n})}function R(e){delete l[e];for(const n of Object.keys(i))i[n]===e&&delete i[n]}function j(){return Object.keys(l)}function I(e){return e=(e||"").toLowerCase(),l[e]||l[i[e]]}function P(e,n){let{languageName:t}=n;"string"===typeof e&&(e=[e]),e.forEach((e=>{i[e.toLowerCase()]=t}))}function C(e){const n=I(e);return n&&!n.disableAutodetect}function T(e){e["before:highlightBlock"]&&!e["before:highlightElement"]&&(e["before:highlightElement"]=n=>{e["before:highlightBlock"](Object.assign({block:n.el},n))}),e["after:highlightBlock"]&&!e["after:highlightElement"]&&(e["after:highlightElement"]=n=>{e["after:highlightBlock"](Object.assign({block:n.el},n))})}function D(e){T(e),o.push(e)}function B(e){const n=o.indexOf(e);-1!==n&&o.splice(n,1)}function L(e,n){const t=e;o.forEach((function(e){e[t]&&e[t](n)}))}function H(e){return ce("10.7.0","highlightBlock will be removed entirely in v12.0"),ce("10.7.0","Please use highlightElement now."),_(e)}"undefined"!==typeof window&&window.addEventListener&&window.addEventListener("DOMContentLoaded",S,!1),Object.assign(e,{highlight:f,highlightAuto:x,highlightAll:A,highlightElement:_,highlightBlock:H,configure:U,initHighlighting:N,initHighlightingOnLoad:v,registerLanguage:O,unregisterLanguage:R,listLanguages:j,getLanguage:I,registerAliases:P,autoDetection:C,inherit:xe,addPlugin:D,removePlugin:B}),e.debugMode=function(){s=!1},e.safeMode=function(){s=!0},e.versionString=ye,e.regex={concat:b,lookahead:h,either:k,optional:g,anyNumberOfTimes:m};for(const t in G)"object"===typeof G[t]&&n(G[t]);return Object.assign(e,G),e},Ne=Ue({});Ne.newInstance=()=>Ue({}),e.exports=Ne,Ne.HighlightJS=Ne,Ne.default=Ne}}]);
//# sourceMappingURL=501.94712908.js.map