import '.././common/css/html.less';
const Html2 = {
    setup() {
        return () => (
            <div>
                <h1>
                    生成HTTP请求消息
                </h1>
                <div className="web-content">
                    <h3>
                        概述
                    </h3>
                    <p>
                        对URL进行解析之后，浏览器确定了Web服务器和文件名，接下来就是根据这些信息来生成HTTP请求消息了。实际上，HTTP消息在格式上是有严格规定的，
                        因此浏览器会按照规定的格式来生成请求消息。
                    </p>
                    <br />
                    <p>
                        首先，请求消息的第一行称为请求行。请求方法可以告诉Web服务器它应该进行怎样的操作。
                        写好方法之后，加一个空格，然后写URI。URI部分格式如下，一般是文件和程序的路径名。
                    </p>
                    <br />
                    <code><i>{"/<目录名>/.../<文件名>"}</i></code>
                    <p>
                        路径名一般来说已经包含在URL中了，因此只要从URL中提取出来原封不动地写上去就好了。
                    </p>
                    <br />
                    <p>
                        第一行的末尾需要写撒花姑娘HTTP的版本号，这是为了标识该消息是基于哪有版本的HTTP规格编写的。到此为止，第一行就结束了。
                    </p>
                    <br />
                    <p>
                        第一行开始为消息头。消息头的功能是用来存放额外的详细信息。如：日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本
                        、数据有效期和最后更新时间等。
                    </p>
                    <br />
                    <p>
                        写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。不过，在使用GET方法
                        的情况下，仅凭方法和URL，Web服务器就能判断需要进行怎样的操作，因此消息体中不需要填写任何数据。消息体结束之后，整个消息也就结束了。
                    </p>
                    <br />
                    <p>
                        当使用POST方法时，需要将表单中填写的信息写在消息中。到此为止，请求消息的生成操作就全部完成了。
                    </p>
                    <div class="tip custom-block">
                        <p class="custom-block-title">GET和POST的区别</p>
                        <div style={{ margin: '25px' }}>
                            <strong>1. 协议层面</strong>
                            <p>
                                访问方法，表示客户端要干嘛，Get表示要拿东西，Post表示要提交东西
                            </p>
                            <strong>2. 应用层面</strong>
                            <p>
                                Get请求体为空，请求头结束换行，请求体留空。
                                Post请求体不为空
                            </p>
                            <strong>1. 浏览器层面</strong>
                            <p>
                                get请求发送数据量有限，get有历史记录，post没有历史记录
                            </p>
                        </div>
                    </div>
                    <h3>
                        收到响应
                    </h3>
                    <p>
                        在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。状态码和响应短语表示的内容一致，但他们的用途不同。状态是一个数字，它主要用来
                        向程序告知执行结果；相对地，响应短语则是一段文字，用来向人们告知执行的结果。
                    </p>
                    <div class="tip custom-block">
                        <p class="custom-block-title">HTTP状态码概要</p>
                        <div className='table_container'>
                            <table>
                                <thead>
                                    <tr>
                                        <th>状态码</th>
                                        <th>含义</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>1xx</td>
                                        <td>告知请求的处理进度和情况</td>
                                    </tr>
                                    <tr>
                                        <td>2xx</td>
                                        <td>成功</td>
                                    </tr>
                                    <tr>
                                        <td>3xx</td>
                                        <td>表示需要进一步操作</td>
                                    </tr>
                                    <tr>
                                        <td>4xx</td>
                                        <td>客户端错误</td>

                                    </tr>
                                    <tr>
                                        <td>5xx</td>
                                        <td>服务器错误</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <h1>
                    DNS服务器查询Web服务器的IP地址
                </h1>
                <div className="web-content">
                    <h3>IP地址</h3>
                    <p>
                        在网络中，所有设备都会被分配一个地址。这个地址就相当于现实中某条路上的"xx号xx室"。其中 "号" 对应的号码是分配给整个子网的，而 "室"
                        对应的号码是分配给子网中的计算机的，这就是网络中的地址。"号" 对应的号码称为网络号， "室" 对应的号码称为主机号，这个地址的整体称为IP地址。
                        通过IP地址我们可以判断出访问对象服务器的位置，从而发送消息到服务器。
                    </p>
                    <h3>
                        子网掩码
                    </h3>
                    <p>
                        通过使用子网掩码，可以确定IP地址中的网络号和主机号的范围。子网掩码中的网络位指示网络号的部分，而主机位指示主机号的部分。根据子网掩码的设置，最高比特位设置为1的表示网络位，最低比特位设置为0的表示主机位。
                    </p>
                    <p>
                        例如，假设有一个IP地址为192.168.1.10，子网掩码为255.255.255.0的情况。在这种情况下，192.168.1 是网络号，10 是主机号。这个IP地址属于以192.168.1为网络号的网络，并且标识该网络中的第10台主机。
                    </p>
                    <p>
                        分离网络号和主机号对于路由器和交换机等网络设备至关重要，因为它们需要根据网络号来决定如何转发数据包。同时，主机号用于在特定网络中标识和定位主机。
                    </p>
                    <div class="tip custom-block">
                        <p class="custom-block-title">网络号与子网掩码</p>
                        <div style={{ margin: '10px' }}>
                            <p>
                                网络号是指用于标识网络的一部分IP地址。它是在网络层中使用的一部分，用于在网络中定位和识别不同的网络。网络号可以视为一个网络的身份证，用于区分不同的网络。
                            </p>
                            <p>
                                主机号是指在特定网络中标识主机（计算机、设备）的一部分IP地址。主机号用于在特定网络中唯一标识一个主机。它可以看作是一个网络中的个体身份证，用于在该网络中区分不同的主机。
                            </p>
                        </div>
                    </div>
                    <h3>
                        提供查询IP地址的功能——Socket库
                    </h3>
                    <p>
                        让我们把向Web服务器发送请求消息的事情放一放，先来探索一下DNS。
                    </p>
                    <p>
                        向DNS服务器发出查询，也就是向DNS服务器发送查询消息，并接收服务器返回的响应消息。换句话说，对于DNS服务器，我们的计算机上一定有相应的DNS客户端，而相当于
                        DNS客户端部分称为DNS解析器。通过DNS查询IP地址的操作称为域名解析，因此负责执行解析这一操作的就叫解析器了。
                    </p>
                    <p>
                        解析器是包含在Socket库中的一段C语言程序，它是其中一种程序组件。通过下面这样对解析器的调用，就完成了查询IP地址的操作。
                    </p>
                    <br />

                    <div>
                        <code>
                            {"<内存地址> = gethotbyname('www.lab.glasscom.com')"};
                        </code>
                    </div>
                    <br />
                    <p>运行这一行程序后，服务器IP地址会被写入指定的内存地址中</p>
                    <h3>
                        解析器原理
                    </h3>
                    <p>
                        一般来说，网络程序(这里指浏览器)调用解析器时程序的控制流程就会转移到解析器内部。当程序控制流程转移时，应用程序本身的工作就会暂停。
                        然后解析器也要生成发送消息的请求头，，并发送给DNS服务器，在这里，通过调用操作系统的协议栈，控制流程又会再次转移，协议栈会执行发送消息的操作，然后通过网卡
                        将消息发送给DNS服务器。
                    </p>
                    <div class="tip custom-block">
                        <p class="custom-block-title">TIPS</p>
                        <div style={{ margin: '10px' }}>
                            <p>
                                向DNS服务器发送消息时，我们当然也要知道DNSF服务器的IP地址.只不过这个IP地址是作为TCP/IP的一个设置项目实现设置好的，不需要再去查询了。
                            </p>
                            
                        </div>
                    </div>
                </div>
                <h1>
                    委托协议栈发送消息
                </h1>
                <div className="web-content">
                    <h3>
                        数据收发操作概览
                    </h3>
                    <p>
                        <strong>向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用Socket库中的程序组件</strong>
                    </p>
                    <p>
                        简单来说，收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。
                    </p>
                    <p>
                        在进行收发数据操作之前，双方需要先建立起这条管道。建立管道的关键在于管道两段的数据出入口，这些出入口称为
                        <code style={{width:'9%'}}>套接字</code>。
                        首先，服务器一方先创建套接字，然后等待客户端向该套接字连接管道。当服务器进入等待状态时，客户端就可以连接管道了。
                        接下来就像我们刚刚讲过的一样，只要将数据送入套接字就可以收发数据了。
                    </p>
                    <p>
                        当数据发送完毕后，管道会被断开，断开可以由任意一方发起。管道断开后，套接字也会被删除。
                    </p>
                    <br />
                    <p>
                        综上所述，收发数据的操作氛围若干阶段，大致总结为一下4个
                    </p>
                    <br />
                    <p>
                        <span>(1)创建套接字(创建套接字阶段)</span>
                        <span>(2)将管道连接到服务器端的套接字上(连接阶段)</span>
                        <span>(3)收发数据(通信阶段)</span>
                        <span>(4)断开管道并删除套接字(断开阶段)</span>
                    </p>
                    <p>以上四个阶段都是委托协议栈来完成的</p>
                </div>
                <div className="web-content">
                    <h3>
                        创建套接字阶段
                    </h3>
                    <p>
                        <strong>套接字创建阶段，只要调用Socket库中的socket程序组件。</strong>
                    </p>
                    <p>
                        套接字创建完成后，协议栈会返回一个描述符，描述符是用来识别不同的套接字的。
                    </p>
                </div>
                <div className="web-content">
                    <h3>
                        连接阶段：把管道接上去
                    </h3>
                    <p>
                        <strong>接下来，我们需要委托协议栈将客户端创建的套接字与服务器哪边的套接字连接起来。</strong>
                    </p>
                    <p>
                        应用程序通过调用Scoket库中名为connect的程序组件来完成这一操作。
                        这里需要指定描述符、服务器IP地址和端口号这3个参数。
                    </p>
                    <div class="tip custom-block">
                        <p class="custom-block-title">TIPS</p>
                        <div style={{ margin: '10px' }}>
                            <p>
                                <strong>描述符:</strong>应用程序用来识别套接字的机制
                            </p>
                            <p>
                                <strong>IP地址和端口号:</strong>客户端和服务器之间用来识别对方套接字的机制
                            </p>

                        </div>
                    </div>
                </div>
                <div className="web-content">
                    <h3>
                        通信阶段：传递消息
                    </h3>
                    <p>
                        <strong>套接字连接起来后，会进行数据的发送的操作。这里是通过调用Socket的write程序组件来完成的。</strong>
                    </p>
                    <br />
                    <p>
                        首先，应用程序需要在内存中准备好要发送的数据。根据用户输入的网址来生成的HTTP请求消息就是我们要发送的数据。
                        接下来，当调用write时，需要指定描述符和发送数据，然后协议栈就会将数据发送到服务器。
                    </p>
                    <p>
                        当消息返回后，需要执行的是接收消息的操作。接收消息是通过调用read程序组件委托协议栈来完成的。调用
                        read时需要指定存放接收消息到的响应消息的内存地址，这一内存地址称为<strong>接收缓冲区</strong>
                    </p>
                    
                </div>
                <div className="web-content">
                    <h3>
                        断开阶段：收发数据结束
                    </h3>
                    <p>
                        <strong>到了断开阶段，需要调用close程序组件进入断开阶段。</strong>
                    </p>
                    <div class="tip custom-block">
                        <p class="custom-block-title">TIPS</p>
                        <div style={{ margin: '10px' }}>
                            <p>
                               如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开操作。对于
                               同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。
                               在HTTP版本1.1中就可以使用这种方法。
                            </p>
                            <br />
                            <p>
                                <strong>HTTP1.1解决了HTTP时代最重要的两大问题</strong>
                                <span>1.TCP连接无法复用，每次请求都需要重新建立TCP通道，这就需要重复进行三次握手和四次挥手，也就是说每个TCP连接只能发送一个请求</span>
                                <span>2.队头阻塞，每个请求都要过 "独木桥" ，桥宽为一个请求的宽度，也就是说，即使多个请求并行发出，也只能一个接一个地进行排队 </span>
                            </p>
                            <br />
                           <p>
                                <strong>HTTP1引入了长链接和管线化</strong>
                           </p>
                            <p>
                                <span>1.长链接：HTTP1.1支持长连接，且默认开启Connection：keep-alive，这样在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的小号和延迟。</span>
                                <span>2.管线化：当浏览器同时发出多个HTIP请求时，浏览器无需等待上一个请求返回结果，即可处理其他请求。</span>
                                注意: 管线化只是可以使浏览器并行发出请求，并没有从根本上解决队头阻塞的问题，因为对请求的响应仍然要遵循先进先出的原则。
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        )
    }
};
export default Html2;
