{"version":3,"file":"static/js/chunk-ff9c4309.99e00ae9.js","mappings":"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A,gFACA,qFACA,+DACA,uDACA,oEACA,UACA,YACA,mDACA,sCACA,8BACA,6EACA,yEACA,yCACA,+EACA,4EACA,0BACA,iCACA,uCACA,gBACA,qEACA,gEACA,uCACA,SACA,WACA,+CACA,sBACA,OACA,wBACA,sCACA,sBACA,kDACA,iFACA,cACA,kCACA,QACA,6CACA,mCACA,wEACA,6CACA,mDACA,gCACA,qEACA,yDACA,wCACA,QACA,yBACA,iBACA,OACA,cACDA,EAAAA,EAAAA,aAAA,YAAAC,EAAAA,EAAAA,iBAAA,sCAAAD,EAAAA,EAAAA,aAAA,cAAAC,EAAAA,EAAAA,iBAAA,cAAAD,EAAAA,EAAAA,aAAA,iBAAAA,EAAAA,EAAAA,aAAA,WAAAC,EAAAA,EAAAA,iBAAA,uEAAAD,EAAAA,EAAAA,aAAA,iBAAAA,EAAAA,EAAAA,aAAA,iBAAAA,EAAAA,EAAAA,aAAA,WAAAA,EAAAA,EAAAA,aAAA,aAAAA,EAAAA,EAAAA,aAAA,aAkBA,CACC,qBACA,kCACA,sCACA,0CACA,4DACA,uCACA,oFACA,OACA,OACA,sBACA,sCACA,sBACA,kDACA,mFACA,cACA,mCACA,QACA,6CACA,mCACA,wEACA,6CACA,mDACA,gCACA,qEACA,yDACA,wCACA,oGACA,cACA,sBACA,oDACA,oEACA,+FACA,UACA,iCACA,QACA,yBACA,iBACA,OACA,cACDA,EAAAA,EAAAA,aAAA,iBAAAA,EAAAA,EAAAA,aAAA,YAAAC,EAAAA,EAAAA,iBAAA,eAAAD,EAAAA,EAAAA,aAAA,cAAAC,EAAAA,EAAAA,iBAAA,YAAAA,EAAAA,EAAAA,iBAAA,uBAAAD,EAAAA,EAAAA,aAAA,iBAAAA,EAAAA,EAAAA,aAAA,WAAAC,EAAAA,EAAAA,iBAAA,6DAAAD,EAAAA,EAAAA,aAAA,iBAAAA,EAAAA,EAAAA,aAAA,iBAAAA,EAAAA,EAAAA,aAAA,WAAAA,EAAAA,EAAAA,aAAA,aAAAA,EAAAA,EAAAA,aAAA,aAkBA,CACC,qBACA,kCACA,sCACA,0CACA,4DACA,uCACA,oFACA,OACA,OACA,sBACA,sCACA,sBACA,kDACA,mFACA,cACA,mCACA,QACA,6CACA,mCACA,wEACA,6CACA,mDACA,gCACA,qEACA,yDACA,wCACA,oGACA,cACA,sBACA,oDACA,oEACA,+FACA,UACA,iCACA,QACA,yBACA,iBACA,OACA,kBASlB,GAEF,W","sources":["webpack://my-website/./src/pages/advance/html/build/webpack.jsx"],"sourcesContent":["import \"../common/css/html.less\";\nimport hljs from \"highlight.js/lib/core\";\nimport javascript from \"highlight.js/lib/languages/javascript\";\nimport { onMounted } from \"vue\";\nimport { useRoute } from \"vue-router\";\n\nconst Build = {\n  setup() {\n    hljs.registerLanguage(\"javascript\", javascript);\n    const route = useRoute();\n    onMounted(() => {\n      hljs.highlightAll();\n    });\n    return () => (\n      <div>\n        <h1>\n          webpack的打包原理\n          <a\n            class=\"header-anchor\"\n            href=\"#webpack的打包原理\"\n            aria-label='Permalink to \"webpack的打包原理 {#webpack的打包原理}\"'\n          ></a>\n        </h1>\n        <div className=\"web-content\">\n          <div>\n            <h3 id=\"process\">打包流程</h3>\n            <p>\n              <span>打包开始前的准备工作</span>\n              <span>打包过程中(编译阶段)</span>\n              <span>打包结束后(成功和失败)</span>\n            </p>\n            <br />\n            这里考虑到<code>watch mode</code>\n            (当文件变化时，将重新进行编译),要把编译阶段单独解耦。\n            <br />\n            <h4>xxxxxxx1</h4>\n            <br />\n            <p>\n              webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段\n            </p>\n            <p>\n              webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段\n            </p>\n            <img src=\"\" alt=\"\" className=\"src\" />\n            <br />\n            <h4>xxxxxxx2</h4>\n            <p>\n              webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段\n            </p>\n            <p>\n              webpack源码中，compiler代表这上面说得三个阶段，在它上面挂载着各种生命周期函数，而compilation专门负责编译相关的工作,也就是打包过程这个阶段\n            </p>\n          </div>\n          <br />\n          <div>\n            <h3 id=\"stream\">实现webpack事件流</h3>\n            <p>\n              这里需要借助Tapable，它是一个类似与node.js中的EventEmitter的库，但\n              <strong>专注于自定义事件的触发和处理</strong>\n              通过Tapable我们可以注册自定义事件，然后在适当的时机去执行自定义事件。\n            </p>\n            <br />\n            <p>\n              我们可以通过tapable先注册一系列的生命周期函数，然后在合适的时间点执行。\n            </p>\n            <br />\n            比如：\n            <p>\n              <pre>\n                <code class=\"language-javascript\">\n                  {[\n                    \"const {'SyncHook'} = require('tapable'), //这是一个同步钩子\",\n                    \"\\n//第一步：实例化钩子函数，可以在这里定义形参\",\n                    \"\\nconst syncHook = new SyncHook(['author', 'age'])\",\n                    \"\\n//第二步：注册事件1\",\n                    \"\\nsyncHook.tap('监听器1', (name, age)=>{\\n console.log('监听器1:', 'name', 'age')\\n});\",\n                    \"\\n//第三步：注册事件2\",\n                    \"\\nsyncHook.tap('监听器2', (name) =>;{\\n console.log('监听器2', name)\\n});\",\n                    \"\\n//第四步：注册事件3\",\n                    \"\\nsyncHook.tap('监听器3', (name) =>;{\\n console.log('监听器3', name)\\n});\",\n                    \"\\n//第五步：触发事件，这里传的是实参，会被每一个注册函数接收到\",\n                    \"\\nsyncHook.call('麦林', '100')\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            在webpack中，就是通过tapable在compiler和compilation上像这样挂载着一系列\n            <code>生命周期Hook</code>，它就像是一座桥梁，宽川着整个构建过程:\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compiler {\",\n                    \"\\n  constructor() {\",\n                    \"\\n    //它内部提供了很多钩子\",\n                    \"\\n    this.hooks = {\",\n                    \"\\n      run: new SyncHook(), //会在编译刚开始的时候触发此钩子\",\n                    \"\\n      done: new SyncHook(), //会在编译结束的时候触发此钩子\",\n                    \"\\n    };\",\n                    \"\\n  };\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n          </div>\n          <br />\n          <div>\n            <h3 id=\"realization\">具体实现</h3>\n            <ul>\n              <li>(1) 搭建结构，读取配置参数</li>\n              <li>\n                (2) 用配置参数对象初始化<code>Compiler</code>对象\n              </li>\n              <li>(3) 挂载配置文件中的插件</li>\n              <li>\n                (4) 执行<code>Compiler</code>对象的<code>run</code>\n                方法开始执行编译\n              </li>\n              <li>\n                (5) 根据配置文件中<code>entry</code>配置项找到所有入口\n              </li>\n              <li>\n                (6) 从入口文件出发，调用配置的<code>loader</code>\n                规则，对各模块进行编译\n              </li>\n              <li>(7) 找出此模块所以来的模块，再对依赖模块进行编译</li>\n              <li>\n                (8) 等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块\n                <code>chunk</code>\n              </li>\n              <li>\n                (9) 把各个代码块<code>chunk</code>\n                转换成一个一个文件加入到输出列表\n              </li>\n              {/* <li>(10) 确定好输出内容之后，根据配置的输出路径和文件名，将文件内容写入到文件系统</li> */}\n            </ul>\n            <br />\n            <h4>(1)、搭建结构，读取配置参数</h4>\n            <br />\n            <p>\n              webpack的本质是一个函数，它接受一个配置信息作为参数，执行返回一个{\" \"}\n              <span>\n                <code>compiler对象</code>\n              </span>\n              ，调用compiler对象中的run方法则启动编译。run\n              方法接受一个回调，可以用来查看编译过程中的错误信息或编译信息\n            </p>\n            <br />\n            <div>\n              <i>搭建结构:</i>\n            </div>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compiler{\",\n                    \"\\n constructor(){}\",\n                    \"\\n\\n run(callback){}\",\n                    \"\\n}\",\n                    \"\\n\\n\",\n                    \"//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数\",\n                    \"\\nfunction webpack(webpackOptions) {\",\n                    \"\\n  const compiler = new Compiler()\",\n                    \"\\n  return compiler;\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <h4>\n              (2)、用配置参数对象初始化<code>Compiler</code>对象\n            </h4>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compiler{\",\n                    \"\\n constructor(wewbpackOptions){\",\n                    \"\\n   this.options = webpackOptions, //存储配置信息\",\n                    \"\\n   //它内部提供了很多钩子\",\n                    \"\\n    this.hooks = {\",\n                    \"\\n      run: new SyncHook(), //会在编译刚开始的时候触发此钩子\",\n                    \"\\n      done: new SyncHook(), //会在编译结束的时候触发此钩子\",\n                    \"\\n    };\",\n                    \"}\",\n                    \"\\n}\",\n                    \"\\n\\n\",\n                    \"//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数\",\n                    \"\\nfunction webpack(webpackOptions) {\",\n                    \"\\n  const compiler = new Compiler()\",\n                    \"\\n  return compiler;\",\n                    \"}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <h4>(3)、挂载配置文件中的插件</h4>\n            <br />\n            <p>\n              webpack plugin 是一个带有apply方法的构造函数。apply方法接收{\" \"}\n              <span>\n                <code>compiler对象</code>\n              </span>\n              为参数，当webpack内部进行插件挂载时会执行apply函数。我们可以在\n              apply方法中订阅各种生命周期钩子，当到达对应的时间点时就会执行。\n            </p>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"//自定义插件WebpackRunPlugin\",\n                    \"\\nclass WebpackRunPlugin{\",\n                    \"\\n apply(compiler){\",\n                    \"\\n   compiler.hooks.run.tap('WebpackRunPlugin',()=>{\",\n                    \"\\n     console.log('开始编译')\",\n                    \"\\n   });\",\n                    \"\\n}\",\n                    \"\\n\\n\",\n                    \"//自定义插件WebpackDonePlugin\",\n                    \"\\nclass WebpackRunPlugin{\",\n                    \"\\n apply(compiler){\",\n                    \"\\n   compiler.hooks.done.tap('WebpackDonePlugin',()=>{\",\n                    \"\\n     console.log('编译完成')\",\n                    \"\\n   });\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <p>webpack.config.js:</p>\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"const {WebpackRunPlugin,WebpackDonePlugin} = require('./webpack');\",\n                    \"\\nmodule.exports = {\",\n                    \"\\n plugins:[new WebpackRunPlugin(),new WebpackDonePlugin()]\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <p>执行插件的apply方法</p>\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"//第一步：搭建结构，读取配置参数，这里接受的是webpack.config.js中的参数\",\n                    \"\\nfunction webpack(webpackOptions){\",\n                    \"\\n  //第二步：用配置参数对象初始化`compiler`对象\",\n                    \"\\n  const compiler = new Compiler(webpackOptions);\",\n                    \"\\n  // 第三步：挂载配置文件中的插件\",\n                    \"\\n  const {plugins} = webpackOptions;\",\n                    \"\\n  for(let plugin of plugins){\",\n                    \"\\n    plugin.apply(compiler);\",\n                    \"\\n  }\",\n                    \"\\n  return compiler;\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <h4>(4) 执行Compiler对象的run方法开始执行编译</h4>\n            <br />\n            <p>\n              在正式开始编译前，我们需要先调用Compiler中的run钩子，表示开始启动编译；编译结束后，需要调用done钩子，表示编译完成\n            </p>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compiler{\",\n                    \"\\n constructor(){\",\n                    \"\\n  //省略\",\n                    \"\\n}\",\n                    \"\\n compiler(){\",\n                    \"\\n  //\",\n                    \"\\n}\",\n\n                    \"\\n\\n//第四步：执行`compiler` 对象的`run方法开始执行编译`\",\n                    \"\\n run(callback){\",\n                    \"\\n   this.hooks.run.call(); //在编译前触发触发run钩子\",\n                    \"\\n   const onCompiled = ()=>{\",\n                    \"\\n     this.hooks.run.call(); //在编译前触发触发run钩子\",\n                    \"\\n   };\",\n                    \"\\n   this.compiler(onCompiled); //开始编译，成功之后调用onCompiled\",\n                    \"\\n }\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <p>\n              编译这个阶段需要单独解耦出来，通过\n              <span>\n                <code>Compilation</code>\n              </span>\n              来完成，定义\n              <span>\n                <code>Compilation</code>\n              </span>\n              大致结构：\n            </p>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compiler{\",\n                    \"\\n  //省略其他\",\n                    \"\\n run(callback){\",\n                    \"\\n //省略\",\n                    \"\\n }\",\n                    \"\\n compile(callback){\",\n                    \"\\n   let compilation = new Compilation(this.options);\",\n                    \"\\n   compilation.build(callback); //执行compilation的build方法进行编译，编译成功之后执行回调\",\n                    \"\\n }\",\n                    \"\\n}\",\n                    \"\\n\\n\",\n                    \"class Compilation{\",\n                    \"\\n constructor(webpackOptions){\",\n                    \"\\n   this.options = webpackOptions;\",\n                    \"\\n   this.modules = []; //本次编译所有生成出来的模块\",\n                    \"\\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块\",\n                    \"\\n   this.assets = []; //本次编译产出的资源文件\",\n                    \"\\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译\",\n                    \"\\n }\",\n                    \"\\n\\n\",\n                    \"\\n build(callback){\",\n                    \"\\n  // 这里开始做编译工作，编译成功之后执行callback\",\n                    \"\\n  callback()\",\n                    \"\\n }\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <h4>\n              (5) 根据配置文件中的<code>entry</code>配置项找到所有的入口\n            </h4>\n            <br />\n            <p>现在我们开始进行编译</p>\n            <br />\n            <p>\n              编译开始前，我需要先知道入口文件，而\n              <span>\n                <code>入口的配置方式</code>\n              </span>\n              有多种，可以是字符串，也可以是对象，这一步是统一配置信息的格式，找出\n              所有入口(考虑多入口打包的场景)\n            </p>\n            <br />\n\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compilation{\",\n                    \"\\n constructor(webpackOptions){\",\n                    \"\\n   this.options = webpackOptions;\",\n                    \"\\n   this.modules = []; //本次编译所有生成出来的模块\",\n                    \"\\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块\",\n                    \"\\n   this.assets = []; //本次编译产出的资源文件\",\n                    \"\\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译\",\n                    \"\\n }\",\n                    \"\\n\\n\",\n                    \"\\n build(callback){\",\n                    \"\\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口\",\n                    \"\\n  let entry = {};\",\n                    \"\\n  if(typeof this.options.entry === 'string'){\",\n                    \"\\n    entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容\",\n                    \"\\n  }else {\",\n                    \"\\n   entry = this.options.entry;\",\n                    \"\\n  }\",\n                    \"\\n\\n  //编译成功执行callback\",\n                    \"\\n  callback()\",\n                    \"\\n }\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <h4>\n              (6) 从入口文件出发，调用配置的<code>loader</code>\n              规则，对各模块进行编译\n            </h4>\n            <br />\n            <p>\n              loader\n              本质上就是函数，接收资源文件或者上一个loader产生的结果作为入参，最终输出转换后的结果\n            </p>\n            <br />\n            <p>写两个自定义loader配置到webpack.config.js中：</p>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"const loader1 = () = > {\",\n                    \"\\n return source + '// 给你的代码加点注释：loader1';\",\n                    \"\\n};\",\n                    \"\\n\\n\",\n                    \"const loader2 = () = > {\",\n                    \"\\n return source + '// 给你的代码加点注释：loader2';\",\n                    \"\\n};\",\n                    \"\\n\\n//webpack.config.js:\",\n                    \"const {loader1,loader2} = require('./webpack');\",\n                    \"\\nmodule.exports = {\",\n                    \"\\n modules:{\",\n                    \"\\n  rules:[\",\n                    \"\\n   {\",\n                    \"\\n    test:/.js$/\",\n                    \"\\n    use:[loader1,loader2]\",\n                    \"\\n   }\",\n                    \"\\n  ]\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <p>\n              这一步骤将从入口文件出发，然后查找出对应的 Loader\n              对源代码进行翻译和替换。主要有三点\n            </p>\n            <br />\n            <p>\n              <label>1.入口文件的绝对路径添加到依赖数组中；</label>\n              <label>\n                2.得到入口模块的\n                <span>\n                  <code>module</code>\n                </span>\n                对象；(读取模块内容，创建模块对象，对源代码进行翻译转换)\n              </label>\n              <label>\n                3.将生成的入口文件\n                <span>\n                  <code>module</code>\n                </span>\n                对象push进行this.modules中；\n              </label>\n            </p>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"const baseDir = process.cwd().replace(//g,'/');\",\n                    \"\\n\\n\",\n                    \"class Compilation{\",\n                    \"\\n constructor(webpackOptions){\",\n                    \"\\n   this.options = webpackOptions;\",\n                    \"\\n   this.modules = []; //本次编译所有生成出来的模块\",\n                    \"\\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块\",\n                    \"\\n   this.assets = []; //本次编译产出的资源文件\",\n                    \"\\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译\",\n                    \"\\n }\",\n                    \"\\n\\n\",\n                    \"\\n buildModule(){\",\n                    \"\\n   // 读取模块内容。获取源代码\",\n                    \"\\n   let sourceCode = fs.readFileSync(modulePath,'utf8');\",\n                    \"\\n   // buildModule最终会返回一个modules对象，每个模块都会有一个id，id是相对于根目录的相对路径\",\n                    \"\\n   let moduleId = './' + path.posix.relative(baseDir,modulePath); //模块id：从根目录出发，找到与该模块的相对路径(./src/index.js)\",\n                    \"\\n   // 创建模块对象\",\n                    \"\\n   let module = {\",\n                    \"\\n     id: moduleId,\",\n                    \"\\n     names: [name], //names设计成数组是因为代表的是此模块属于哪个代码块，可能属于多个代码块\",\n                    \"\\n     dependencies: [], //它依赖的模块\",\n                    \"\\n     _source: '', //该模块的代码信息\",\n                    \"\\n   };\",\n                    \"\\n   // 找到对应的`loader`对源代码进行翻译和转换\",\n                    \"\\n   let loaders = []\",\n                    \"\\n   let { rules = []} = this.options.module;\",\n                    \"\\n   rules.forEach(rule=>{\",\n                    \"\\n     let { test } = rule;\",\n                    \"\\n     // 如果模块的路径和正则匹配，就把此规则对应的loader添加到loader数组中\",\n                    \"\\n     if(modulePath.match(test)){\",\n                    \"\\n       loaders.push(...rule.use)\",\n                    \"\\n     }\",\n                    \"\\n   });\",\n                    \"\\n\\n//自右向做左对模块进行转移\",\n                    \"\\n sourceCode = loaders.reduceRight((code , loader) =>{\",\n                    \"\\n   return loader(code);\",\n                    \"\\n}, sourceCode);\",\n                    \"\\n\\n   return module;\",\n                    \"\\n }\",\n                    \"\\n\\n build(callback){\",\n                    \"\\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口\",\n                    \"\\n  let entry = {};\",\n                    \"\\n  if(typeof this.options.entry === 'string'){\",\n                    \"\\n  entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容\",\n                    \"\\n  }else {\",\n                    \"\\n  entry = this.options.entry;\",\n                    \"\\n  }\",\n                    \"\\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译\",\n                    \"\\n  for(let entryName in entry){\",\n                    \"\\n  let entryFilePath = path.posix.join(baseDir,entry[entryName]); \",\n                    \"\\n  //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 \",\n                    \"\\n  this.fileDependencies.push(entryFilePath);\",\n                    \"\\n  //2. 得到入口模块的`module` 对象\",\n                    \"\\n  let entryModule = this.buildModule(entryName,entryFilePath) \",\n                    \"\\n  //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 \",\n                    \"\\n  this.modules.push(entryModule);\",\n                    \"\\n  }\",\n                    \"\\n\\n  //编译成功执行callback\",\n                    \"\\n  callback()\",\n                    \"\\n }\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <h4>(7) 找出此模块所依赖的模块，再对依赖模块进行编译</h4>\n            <br />\n            <p>\n              该步骤经过细化可以将其拆分成十个小步骤：\n              <span>（7.1）：先把源代码编译成 AST</span>\n              <span>\n                （7.2）：在 AST 中查找 require\n                语句，找出依赖的模块名称和绝对路径\n              </span>\n              <span>\n                （7.3）：将依赖模块的绝对路径 push 到 this.fileDependencies 中\n              </span>\n              <span>（7.4）：生成依赖模块的模块 id</span>\n              <span>（7.5）：修改语法结构，把依赖的模块改为依赖模块 id</span>\n              <span>\n                （7.6）：将依赖模块的信息 push 到该模块的 dependencies 属性中\n              </span>\n              <span>\n                （7.7）：生成新代码，并把转译后的源代码放到 module._source\n                属性上\n              </span>\n              <span>\n                （7.8）：对依赖模块进行编译（对 module 对象中的 dependencies\n                进行递归执行 buildModule ）\n              </span>\n              <span>\n                （7.9）：对依赖模块编译完成后得到依赖模块的 module 对象，push 到\n                this.modules 中\n              </span>\n              <span>\n                （7.10）：等依赖模块全部编译完成后，返回入口模块的 module 对象\n              </span>\n            </p>\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"const parser = require('@babel/parser');\",\n                    \"\\n let types = require('@babel/types'); //用来生成或者判断节点的AST语法树的节点\",\n                    \"\\n const traverse = require('@babel/traverse').default;\",\n                    \"\\n const generator = require('@babel/generator').default;\",\n                    \"\\n\",\n                    \"\\n//获取文件路径\",\n                    \"\\n function tryExtensions(modulePath, extensions) {\",\n                    \"\\n   if (fs.existsSync(modulePath)) {\",\n                    \"\\n     return modulePath;\",\n                    \"\\n   }\",\n                    \"\\n   for (let i = 0; i < extensions?.length; i++) {\",\n                    \"\\n     let filePath = modulePath + extensions[i];\",\n                    \"\\n     if (fs.existsSync(filePath)) {\",\n                    \"\\n       return filePath;\",\n                    \"\\n     }\",\n                    \"\\n   }\",\n                    \"\\n   throw new Error(`无法找到${modulePath}`);\",\n                    \"\\n }\",\n                    \"\\n\\nconst baseDir = process.cwd().replace(//g,'/');\",\n                    \"\\n\\n\",\n                    \"class Compilation{\",\n                    \"\\n constructor(webpackOptions){\",\n                    \"\\n   this.options = webpackOptions;\",\n                    \"\\n   this.modules = []; //本次编译所有生成出来的模块\",\n                    \"\\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块\",\n                    \"\\n   this.assets = []; //本次编译产出的资源文件\",\n                    \"\\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译\",\n                    \"\\n }\",\n                    \"\\n\\n\",\n                    \"\\n buildModule(){\",\n                    \"\\n  //省略其他\",\n                    \"\\n\\n//自右向做左对模块进行转移\",\n                    \"\\n  sourceCode = loaders.reduceRight((code , loader) =>{\",\n                    \"\\n   return loader(code);\",\n                    \"\\n  }, sourceCode);\",\n                    \"\\n\\n//通过loader翻译后的内容一定得是js内容，因为最后得走我们babel-parse，只有js才能成编译AST\",\n                    \"\\n  //第七步：找出此模块所依赖的模块，再对依赖模块进行编译\",\n                    \"\\n  //7.1:先把源代码编译成 [AST](https://astexplorer.net/)\",\n                    \"\\n   let ast = parser.parse(sourceCode, { sourceType: 'module' });\",\n                    \"\\n    traverse(ast, {\",\n                    \"\\n    CallExpression: (nodePath) => {\",\n                    \"\\n    const { node } = nodePath;\",\n                    \"\\n    //7.2在 `AST` 中查找 `require` 语句，找出依赖的模块名称和绝对路径\",\n                    \"\\n    if (node.callee.name === 'require') {\",\n                    \"\\n      let depModuleName = node.arguments[0].value; //获取依赖的模块\",\n                    \"\\n      let dirname = path.posix.dirname(modulePath); //获取当前正在编译的模所在的目录\",\n                    \"\\n      let depModulePath = path.posix.join(dirname, depModuleName); //获取依赖模块的绝对路径\",\n                    \"\\n      let extensions = this.options.resolve?.extensions || [ '.js' ]; //获取配置中的extensions\",\n                    \"\\n      depModulePath = tryExtensions(depModulePath, extensions); //尝试添加后缀，找到一个真实在硬盘上存在的文件\",\n                    \"\\n      //7.3:将依赖模块的绝对路径 push 到 `this.fileDependencies` 中\",\n                    \"\\n      this.fileDependencies.push(depModulePath);\",\n                    \"\\n      //7.4:生成依赖模块的`模块 id`\",\n                    \"\\n      let depModuleId = './' + path.posix.relative(baseDir, depModulePath);\",\n                    \"\\n      //7.5:修改语法结构，把依赖的模块改为依赖`模块 id` require('./name')=>require('./src/name.js')\",\n                    \"\\n      node.arguments = [types.stringLiteral(depModuleId)];\",\n                    \"\\n      //7.6:将依赖模块的信息 push 到该模块的 `dependencies` 属性中\",\n                    \"\\n      module.dependencies.push({ depModuleId, depModulePath });\",\n                    \"\\n    }\",\n                    \"\\n    });\",\n                    \"\\n\\n//7.7：生成新代码，并把转译后的源代码放到 `module._source` 属性上\",\n                    \"\\n   let { code } = generator(ast);\",\n                    \"\\n   module._source = code;\",\n                    \"\\n   //7.8：对依赖模块进行编译（对 `module 对象`中的 `dependencies` 进行递归执行 `buildModule` ）\",\n                    \"\\n   module.dependencies.forEach(({ depModuleId, depModulePath }) => {\",\n                    \"\\n   //考虑到多入口打包 ：一个模块被多个其他模块引用，不需要重复打包\",\n                    \"\\n   let existModule = this.modules.find((item) => item.id === depModuleId);\",\n                    \"\\n   //如果modules里已经存在这个将要编译的依赖模块了，那么就不需要编译了，直接把此代码块的名称添加到对应模块的names字段里就可以\",\n                    \"\\n   if (existModule) {\",\n                    \"\\n     //names指的是它属于哪个代码块chunk\",\n                    \"\\n     existModule.names.push(name);\",\n                    \"\\n   } else {\",\n                    \"\\n     //7.9：对依赖模块编译完成后得到依赖模块的 `module 对象`，push 到 `this.modules` 中\",\n                    \"\\n     let depModule = this.buildModule(name, depModulePath);\",\n                    \"\\n     this.modules.push(depModule);\",\n                    \"\\n   }\",\n                    \"\\n   });\",\n                    \"\\n   //7.10：等依赖模块全部编译完成后，返回入口模块的 `module` 对象\",\n                    \"\\n   return module;\",\n                    \"\\n }\",\n                    \"\\n\\n build(callback){\",\n                    \"\\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口\",\n                    \"\\n  let entry = {};\",\n                    \"\\n  if(typeof this.options.entry === 'string'){\",\n                    \"\\n  entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容\",\n                    \"\\n  }else {\",\n                    \"\\n  entry = this.options.entry;\",\n                    \"\\n  }\",\n                    \"\\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译\",\n                    \"\\n  for(let entryName in entry){\",\n                    \"\\n    let entryFilePath = path.posix.join(baseDir,entry[entryName]); \",\n                    \"\\n    //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 \",\n                    \"\\n    this.fileDependencies.push(entryFilePath);\",\n                    \"\\n    //2. 得到入口模块的`module` 对象\",\n                    \"\\n    let entryModule = this.buildModule(entryName,entryFilePath) \",\n                    \"\\n    //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 \",\n                    \"\\n    this.modules.push(entryModule);\",\n                    \"\\n  }\",\n                    \"\\n\\n  //编译成功执行callback\",\n                    \"\\n  callback()\",\n                    \"\\n }\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <h4>\n              (8) 等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块\n              <code>chunk</code>\n            </h4>\n            <br />\n            <p>\n              一般来说，每个入口文件会对应一个代码块chunk，每个代码块chunk里面会放着本入口模块和它依赖的模块，这里暂时不考虑代码分割\n            </p>\n            <br />\n\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compilation{\",\n                    \"\\n constructor(webpackOptions){\",\n                    \"\\n   this.options = webpackOptions;\",\n                    \"\\n   this.modules = []; //本次编译所有生成出来的模块\",\n                    \"\\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块\",\n                    \"\\n   this.assets = []; //本次编译产出的资源文件\",\n                    \"\\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译\",\n                    \"\\n }\",\n                    \"\\n\\n\",\n                    \"\\n build(callback){\",\n                    \"\\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口\",\n                    \"\\n  let entry = {};\",\n                    \"\\n  if(typeof this.options.entry === 'string'){\",\n                    \"\\n    entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容\",\n                    \"\\n  }else {\",\n                    \"\\n   entry = this.options.entry;\",\n                    \"\\n  }\",\n                    \"\\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译\",\n                    \"\\n  for(let entryName in entry){\",\n                    \"\\n    let entryFilePath = path.posix.join(baseDir,entry[entryName]); \",\n                    \"\\n    //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 \",\n                    \"\\n    this.fileDependencies.push(entryFilePath);\",\n                    \"\\n    //2. 得到入口模块的`module` 对象\",\n                    \"\\n    let entryModule = this.buildModule(entryName,entryFilePath) \",\n                    \"\\n    //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 \",\n                    \"\\n    this.modules.push(entryModule);\",\n                    \"\\n    //第八步：等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 `chunk`（一般来说，每个入口文件会对应一个代码块`chunk`，每个代码块`chunk`里面会放着本入口\",\n                    \"模块  和它依赖的模块\",\n                    \"\\n    let chunk = {\",\n                    \"\\n     name: entryName, //entryName='main' 代码块的名称\",\n                    \"\\n     entryModule, //此代码块对应的module的对象,这里就是src/index.js 的module对象\",\n                    \"\\n     modules: this.modules.filter((item) => item.names.includes(entryName)), //找出属于该代码块的模块\",\n                    \"\\n    }\",\n                    \"\\n    this.chunks.push(chunk);\",\n                    \"\\n  }\",\n                    \"\\n\\n  //编译成功执行callback\",\n                    \"\\n  callback()\",\n                    \"\\n }\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n            <br />\n            <h4>\n              (9) 把各个代码块<code>chunk</code>转换成一个一个文件加入到输出列表\n            </h4>\n            <br />\n            <p>\n              这一步需要结合配置文件中的output.filename去生成输出文件的文件名称，同时还需要生成运行时代码:\n            </p>\n            <br />\n\n            <br />\n            <p>\n              <pre>\n                <code>\n                  {[\n                    \"class Compilation{\",\n                    \"\\n constructor(webpackOptions){\",\n                    \"\\n   this.options = webpackOptions;\",\n                    \"\\n   this.modules = []; //本次编译所有生成出来的模块\",\n                    \"\\n   this.chunks = []; //本次编译产出的所有的代码块，入口模块和依赖的模块打包一起为代码块\",\n                    \"\\n   this.assets = []; //本次编译产出的资源文件\",\n                    \"\\n   this.fileDependencies = []; // 本次打包涉及的文件，这里主要是为了实现watch模式下监听文件的变化，文件变化后会重新编译\",\n                    \"\\n }\",\n                    \"\\n\\n\",\n                    \"\\n build(callback){\",\n                    \"\\n  // 第五步：根据配置文件中的`entry`配置找到所有的入口\",\n                    \"\\n  let entry = {};\",\n                    \"\\n  if(typeof this.options.entry === 'string'){\",\n                    \"\\n    entry.main = this.options.entry; //如果是单入口，将entry:'xx'变成{main:'xx'},这里需要做兼容\",\n                    \"\\n  }else {\",\n                    \"\\n   entry = this.options.entry;\",\n                    \"\\n  }\",\n                    \"\\n  //第六步：从入口文件出发，调用配置的`loader`规则，对各模块进行编译\",\n                    \"\\n  for(let entryName in entry){\",\n                    \"\\n    let entryFilePath = path.posix.join(baseDir,entry[entryName]); \",\n                    \"\\n    //1. 把入口文件的绝对路径添加到以来数组中，记录此次编译依赖的模块 \",\n                    \"\\n    this.fileDependencies.push(entryFilePath);\",\n                    \"\\n    //2. 得到入口模块的`module` 对象\",\n                    \"\\n    let entryModule = this.buildModule(entryName,entryFilePath) \",\n                    \"\\n    //3. 将生成的入口文件`module` 对象 push 进 `this.modules`中 \",\n                    \"\\n    this.modules.push(entryModule);\",\n                    \"\\n    //第八步：等所有模块都编译完成后，根据模块之间的依赖关系，组装代码块 `chunk`（一般来说，每个入口文件会对应一个代码块`chunk`，每个代码块`chunk`里面会放着本入口\",\n                    \"模块  和它依赖的模块\",\n                    \"\\n    let chunk = {\",\n                    \"\\n     name: entryName, //entryName='main' 代码块的名称\",\n                    \"\\n     entryModule, //此代码块对应的module的对象,这里就是src/index.js 的module对象\",\n                    \"\\n     modules: this.modules.filter((item) => item.names.includes(entryName)), //找出属于该代码块的模块\",\n                    \"\\n    }\",\n                    \"\\n    this.chunks.push(chunk);\",\n                    \"\\n  }\",\n                    \"\\n\\n  //编译成功执行callback\",\n                    \"\\n  callback()\",\n                    \"\\n }\",\n                    \"\\n}\",\n                  ]}\n                </code>\n              </pre>\n            </p>\n          </div>\n        </div>\n      </div>\n    );\n  },\n};\nexport default Build;\n"],"names":["Build","setup","hljs","registerLanguage","javascript","useRoute","onMounted","highlightAll","_createVNode","_createTextVNode"],"sourceRoot":""}